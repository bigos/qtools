<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta charset="utf-8"/> <title>Qtools</title> <meta name="viewport" content="width=device-width"/> <meta name="description" content="A collection of tools to aid in development with CommonQt."/> <meta name="author" content="Nicolas Hafner &lt;shinmera@tymoon.eu&gt;"/> <style type="text/css"> body{
          max-width: 1024px;
          margin: 0 auto 0 auto;
          font-family: sans-serif;
          color: #333333;
          font-size: 14pt;
          padding: 5px;
      }
      body>header{
          display:flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
          max-width: 100%;
          text-align: center;
      }
      body>header img{
          max-width: 50%;
      }
      img{
          max-width: 100%;
          max-height: 100%;
      }
      code{
          font-family: Consolas, Inconsolata, monospace;
      }
      a{
          text-decoration: none;
          color: #0055AA;
      }
      a img{
          border: none;
      }
      #documentation{
          text-align: justify;
      }
      #documentation pre{
          margin-left: 20px;
          overflow: auto;
      }
      #documentation img{
          margin: 5px;
      }
      #symbol-index>ul{
          list-style: none;
          padding: 0;
      }
      #symbol-index .package>ul{
          list-style: none;
          padding: 0 0 0 10px;
      }
      #symbol-index .package .nicknames{
          font-weight: normal;
      }
      #symbol-index .package h4{
          display: inline-block;
          margin: 0;
      }
      #symbol-index .package article{
          margin: 0 0 15px 0;
      }
      #symbol-index .package article header{
          font-size: 1.2em;
          font-weight: normal;
      }
      #symbol-index .package .name{
          margin-right: 5px;
      }
      #symbol-index .package .docstring{
          margin: 0 0 0 15px;
          white-space: pre-wrap;
          font-size: 12pt;
      }
      @media (max-width: 800px){
          body{font-size: 12pt;}
      } </style> </head> <body> <header> <h1><img alt="qtools" src="qtools-logo.png"/></h1> <span class="version">1.0.0</span> <p class="description">A collection of tools to aid in development with CommonQt.</p> </header> <main> <article id="documentation">  <div><h2>About Qtools <a href="https://travis-ci.org/Shinmera/qtools"><img src="https://travis-ci.org/Shinmera/qtools.svg?branch=master" alt="Build Status" align="right"/></a></h2> <p>Qtools is a collection of utilities to help development with CommonQt. There are a lot of things in there, from name mapping over garbage handling to widget class definition. Some tools are straightforward, others are quite complex. I'll try to explain everything as best I can.</p> <h2>Fundamentals</h2> <p>There are three layers working beneath Qtools, of which you need to know about in order to understand how to use the various facilities Qtools offers.</p> <h3><a href="http://qt-project.org/doc/qt-4.8/">Qt</a></h3> <p>Qt is a gigantic toolkit that mainly concerns itself with GUI creation. It is cross-platform and written in C++. While its size and large user-base means that it is very mature and usable for pretty much any kind of GUI, the fact that it's written in C++ makes things complicated. The usual way to interoperate with C++ libraries and projects is to create a C API wrapper.</p> <h3><a href="https://techbase.kde.org/Development/Languages/Smoke">Smoke</a></h3> <p>And this is what Smoke does. It generates a C wrapper so that other languages can make use of Qt through C-FFI. Smoke is divided up into a bunch of modules, each being associated with a part of Qt, such as qtcore, qtgui, qtopengl, phonon, etc.</p> <h3><a href="http://common-lisp.net/project/commonqt/">CommonQt</a></h3> <p>The heavy lifting and ground-work that is required to interface with Smoke (and thus with Qt) is done by CommonQt. By itself, CommonQt offers a complete framework to create Qt GUIs from Common Lisp out.</p> <h3><a href="https://shinmera.github.io/qtools/">Qtools</a></h3> <p>Unfortunately, working with CommonQt itself is a bit awkward. While it offers everything you need, the way you have to make use of it is sub-par. Qtools attempts to help with this by offering another layer over CommonQt to smooth everything out. However, since you might not like certain parts of the Qtools ecosystem, it should be possible for you to only use the features you like, rather than being forced to use everything. So, you can always mix and match &quot;plain&quot; CommonQt and Qtools extensions.</p> <h2>Getting Started</h2> <h3>Qt</h3> <p>In case you already know Qt, you may skip this part and go straight to the next section. I'll briefly explain some of the core Qt concepts and how they fit together. However, you should still read the <a href="http://doc.qt.io/qt-4.8/">official Qt documentation</a> for anything that's left unclear.</p> <p>Since Qt is a C++ library it is heavily focused around classes and methods. At the top of the class hierarchy sits <a href="http://doc.qt.io/qt-4.8/qobject.html">QObject</a>. Almost all classes in Qt inherit from this. The more important one for us however is the <a href="http://doc.qt.io/qt-4.8/qwidget.html">QWidget</a> class, which already gives you everything you need to get started. It can act as a window or be contained in other widgets. It has all the sizing mechanics and is properly hooked into the event system that allows you to catch when keys are pressed, the window is resized, and so forth.</p> <p>Usually you create your new widgets by subclassing something like QWidget and then overriding methods to do what you want or simply attach other widgets to it and connect them up so that they can communicate to each other via the signal system. Classes have slots and signals. Signals are a form of method signature that describe a list of arguments and their type. Slots are the corresponding methods that perform actions when a signal reaches them. Wiring things up functions by connecting a signal and a source instance to a slot and a target instance. When then a signal is signalled onto the source instance, the target instance's slot method is called.</p> <p>And that's pretty much all of the core mechanics that you need to know about. For everything else, you usually refer to the documentation page for the specific class involved and see what kind of methods or signals you can use to do what you want. Seriously, the docs are good. I use them constantly while developing.</p> <h3>Qtools</h3> <p>Before getting started with explaining the details on the various parts of Qtools, I'll go through a basic project setup of a project using it.</p> <p>First you will want an ASDF system to define your project. In its dependencies it should contain <code>:qtools</code> and the smoke modules you require, usually just <code>:qtcore</code> and <code>:qtgui</code>.</p> <pre><code>(asdf:defsystem qtools-intro
  ...
  :depends-on (:qtools :qtcore :qtgui))
</code></pre> <p>If you want to just try things out on the REPL real quick, just <code>(ql:quickload '(qtools qtcore qtgui))</code> should suffice.</p> <p>Then of course you'll usually want a package to put all your stuff in. Instead of <code>:use #:cl</code> you will most likely want to <code>:use #:cl+qt</code>. This package combines the symbols of the common-lisp base package, the commonqt package, and qtools. Thus all the symbols and functions you usually need for development are already included.</p> <pre><code>(<a href="http://l1sp.org/cl/defpackage">defpackage</a> #:qtools-intro
  (:use #:cl+qt)
  (:export #:main))
</code></pre> <p>CommonQt, and Qtools itself, require a few extensions to the standard reader syntax. For this reason you will want to change the readtable using <code>named-readtables:in-readtable</code>, which <code>cl+qt</code> includes. Readtable changes are on a <em>per-file</em> basis, so you need both an <code><a href="http://l1sp.org/cl/in-package">in-package</a></code> and an <code>in-readtable</code> call on every file.</p> <pre><code>(<a href="http://l1sp.org/cl/in-package">in-package</a> #:qtools-intro)
(in-readtable :qtools)
</code></pre> <p>This sets up everything you need to get started writing an actual GUI. So let's do that as well. In Qt things are organised as widgets. Windows are widgets, buttons are widgets, text fields are widgets, etc. Qtools mirrors this.</p> <pre><code>(<a href="#QTOOLS:DEFINE-WIDGET">define-widget</a> main-window (QWidget)
  ())
</code></pre> <p>This <code><a href="#QTOOLS:DEFINE-WIDGET">define-widget</a></code> form is syntactically equivalent to <code><a href="http://l1sp.org/cl/defclass">defclass</a></code>. The only change is that the first argument in the superclass list is the Qt class to inherit from. Now we'll want to add some things to display in the widget.</p> <pre><code>(<a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a> (main-window name) (q+:make-qlineedit main-window)
  (<a href="http://l1sp.org/cl/setf">setf</a> (q+:placeholder-text name) &quot;Your name please.&quot;))

(<a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a> (main-window go) (q+:make-qpushbutton &quot;Go!&quot; main-window))
</code></pre> <p>This adds a QLineEdit widget called <code>name</code> to the <code>main-window</code> and sets its placeholder text to <code>&quot;Your name please.&quot;</code>. The second form adds a button called <code><a href="http://l1sp.org/cl/go">go</a></code> with a label of <code>&quot;Go!&quot;</code>. Simple stuff. The body of the <code><a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a></code> form can contain any number of statements. By default, the symbols of all the other subwidgets and slots defined prior to the <code><a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a></code> form are bound to their corresponding values. This is useful if you for example need to define a layout, as we will do now.</p> <pre><code>(<a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a> (main-window layout) (q+:make-qhboxlayout main-window)
  (q+:add-widget layout name)
  (q+:add-widget layout go))
</code></pre> <p>This sets up the displaying part of our GUI, but so far we haven't made it react to anything yet. Reacting to events in Qt happens through signals and slots. Slots are functions that receive signals, and signals are event carriers.</p> <pre><code>(<a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a> (main-window name-set) (<a href="http://l1sp.org/cl/string">string</a>))

(<a href="#QTOOLS:DEFINE-SLOT">define-slot</a> (main-window go) ()
  (<a href="http://l1sp.org/cl/declare">declare</a> (<a href="#QTOOLS:CONNECTED">connected</a> go (pressed)))
  (<a href="http://l1sp.org/cl/declare">declare</a> (<a href="#QTOOLS:CONNECTED">connected</a> name (return-pressed)))
  (<a href="#QTOOLS:SIGNAL!">signal!</a> main-window (name-set string) (q+:text name)))

(<a href="#QTOOLS:DEFINE-SLOT">define-slot</a> (main-window name-set) ((new-name string))
  (<a href="http://l1sp.org/cl/declare">declare</a> (<a href="#QTOOLS:CONNECTED">connected</a> main-window (name-set string)))
  (q+:qmessagebox-information main-window &quot;Greetings&quot; (<a href="http://l1sp.org/cl/format">format</a> NIL &quot;Good day to you, ~a!&quot; new-name)))
</code></pre> <p>We're doing things a bit roundabout here to illustrate creating signals. <code><a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a></code> introduces a new signal called <code>name-set</code> that takes a single <code><a href="http://l1sp.org/cl/string">string</a></code> as argument. We then define a new slot that is connected to the <code><a href="http://l1sp.org/cl/go">go</a></code> button's <code>pressed</code> signal (which has no arguments) as well as the <code>name</code> field's <code>return-pressed</code>. We then simply fetch the current text of our <code>name</code> field and send it out again with our custom signal. The second slot catches this signal again and uses it to display a message box.</p> <p>You can now try and see what kind of magical wonders you have created by using <code><a href="#QTOOLS:WITH-MAIN-WINDOW">with-main-window</a></code> to launch everything: <code>(<a href="#QTOOLS:WITH-MAIN-WINDOW">with-main-window</a> (window 'main-window))</code>. This will block until your window is closed, as Qt needs to capture the thread to handle events.</p> <p>And that's that. The only thing we didn't take a look at here is <code><a href="#QTOOLS:DEFINE-OVERRIDE">define-override</a></code>, which allows you to define override functions for your Qt classes. So, if you for example want to manually draw onto a widget you can override its <code>paintEvent</code> method using this.</p> <pre><code>(<a href="#QTOOLS:DEFINE-OVERRIDE">define-override</a> (main-window paint-event) (event)
  (<a href="http://l1sp.org/cl/declare">declare</a> (<a href="http://l1sp.org/cl/ignore">ignore</a> event))
  (<a href="#QTOOLS:WITH-FINALIZING">with-finalizing</a> ((painter (q+:make-qpainter main-window)))
    (q+:fill-rect painter (q+:rect main-window) (q+:qt.white))))
</code></pre> <p>This'll make the background of our window completely white. The important thing to note here is the <code><a href="#QTOOLS:WITH-FINALIZING">with-finalizing</a></code>. What has been rather well hidden from you so far, is that as Qt is a C++ framework, you will have to do manual memory management. Qtools makes this a lot easier by offering macros and automations to take most of it off of your hands. For example, all the sub widgets we defined are automatically deleted once the main window is.</p> <p>A general note about developing with Qtools/CommonQt: While custom function bodies such as from qt-slots, overrides, initializers, and finalizers reside on the CL side and can thus be redefined at any time and take effect immediately, adding or removing qt-slots and overrides will not affect already created instances. This is to say, if you run your application and recompile your override, the effect will be visible immediately. But if you add a new slot, override, or signal, the existing instance will not have them. This is due to the fact that these things need to be tied to the C++ class, which will not update existing instances when it is changed, like CLOS usually does. This means that if you change a running widget by adding new components, you need to recreate or restart it to see the effects.</p> <h2>Deployment</h2> <p>So, you've built a neat little Qt application and you would like to deploy it and ship it to people that aren't developers. For this, you will want to dump a binary and bundle it together with the necessary shared libraries. Qtools will take care of this for you, to the point where it becomes very trivial to do.</p> <p>You will need an ASDF system that compiles your program and add the following options to your system definition:</p> <pre><code>:defsystem-depends-on (:qtools)
:build-operation &quot;qt-program-op&quot;
:build-pathname &quot;executable-name&quot;
:entry-point &quot;my-package:my-launch-function&quot;
</code></pre> <p>You can change the string of <code>:build-pathname</code> to whatever pathname-name you'd like your executable to have. You should change the stirng of <code>:entry-point</code> to be a designator for an external symbol that is either your main window class name, or a function that handles the launching of your GUI.</p> <p>Once you have updated your ASD, you should launch a clean instance of your implementation from the command line -- make sure not to load slime or anything else that creates threads. Then simply invoke <code>(asdf:operate :build-op :system-name :force T)</code>. For sbcl, that would be:</p> <pre><code>sbcl --eval &quot;(asdf:operate :build-op :system-name :force T)&quot;
</code></pre> <p>This will compile your system, gather some info on it, copy the necessary shared libraries to the deployment folder, and finally dump an image with your system ready to go. It should put it all into a new <code>bin</code> folder within your project's root. If everything went right, you should be able to just launch the executable within and be greeted with your nice GUI. You can then just ZIP up the build folder and ship that-- it should contain all of the necessary shared library dependencies to run outside of your development environment.</p> <p>As an example for a working system that can be deployed, have a look at <a href="https://github.com/shinmera/halftone">halftone</a> or <a href="https://github.com/shirakumo/cl-gamepad">cl-gamepad-visualizer</a>.</p> <p>For more customisation and other details of the deployment system, see the underlying library <a href="https://shinmera.github.io/deploy/">Deploy</a>.</p> <h2>Qtools Components</h2> <h3>Name Conversion</h3> <p>Common Lisp and C++ follow different naming conventions for classes, variables, methods, and types. Qtools offers a couple of functions to attempt to translate between the two. Finding a Qt class can be done with <code><a href="#QTOOLS:FIND-QT-CLASS-NAME">find-qt-class-name</a></code>. It searches a static table of known Qt classes (<code><a href="#QTOOLS:*QT-CLASS-MAP*">*qt-class-map*</a></code>) by first stripping all dashes from the name, and then case-insensitively finding a matching name.</p> <p>Translating method names can be done through <code><a href="#QTOOLS:TO-METHOD-NAME">to-method-name</a></code>, which translates dashes to mean that the next character should be in uppercase. So <code>foo-bar</code> is <code>fooBar</code>. In case you pass it a string instead of a symbol however, it will not do any translation. This is important to take care of edge-cases, where this primitive translation would prohibit using a certain name. If you need a method signature instead of just a name, there are <code><a href="#QTOOLS:SPECIFIED-TYPE-METHOD-NAME">specified-type-method-name</a></code> that takes a name and a list of type specifiers, and <code><a href="#QTOOLS:DETERMINED-TYPE-METHOD-NAME">determined-type-method-name</a></code>, which attempts to determine the type of the arguments, rather than requiring type specifiers directly.</p> <p>Types are translated using <code><a href="#QTOOLS:QT-TYPE-OF">qt-type-of</a></code>, <code><a href="#QTOOLS:EQT-TYPE-OF">eqt-type-of</a></code>, <code><a href="#QTOOLS:QT-TYPE-FOR">qt-type-for</a></code>, and <code><a href="#QTOOLS:TO-TYPE-NAME">to-type-name</a></code>. Where <code><a href="#QTOOLS:QT-TYPE-FOR">qt-type-for</a></code> translates a type specifier and <code><a href="#QTOOLS:QT-TYPE-OF">qt-type-of</a></code> tries to determine the type through a value. Reversing from a Qt type specifier to a CL type is possible with <code><a href="#QTOOLS:CL-TYPE-FOR">cl-type-for</a></code> and <code><a href="#QTOOLS:ECL-TYPE-FOR">ecl-type-for</a></code>.</p> <h3>Object Handling</h3> <p>In C++ there usually is no garbage collector, so you need to carefully clean up yourself or you'll create a memory leak. In Common Lisp we're used to the luxury of not having to worry about this, thanks to garbage collection. Sadly, we cannot use the garbage collector to also take care of C++ objects, as they live in a different world not governed by us. So, garbage collection of Qt objects is still our own worry.</p> <p>To make this all just a smidgeon easier, Qtools introduces a system of <em>finalizables</em>, the central point of which is the <code><a href="#QTOOLS:FINALIZE">finalize</a></code> generic function. This function should take care of all necessary cleanup when an object is no longer needed. For <code>qobject</code>s, this means running eventual cleanup (through <code>finalize-using-class</code>) and then being <code><a href="http://l1sp.org/cl/delete">delete</a></code>d, thus properly removed from memory. However, <code><a href="#QTOOLS:FINALIZE">finalize</a></code> can not only be used for Qt objects, but for anything else as well. Especially interesting here are <code><a href="#QTOOLS:FINALIZABLE">finalizable</a></code> objects, whose slots can specify an additional argument <code>:finalized</code>, which dictates whether <code><a href="#QTOOLS:FINALIZE">finalize</a></code> is run on the slot's value when the class instance is <code><a href="#QTOOLS:FINALIZE">finalize</a></code>d.</p> <p>Often times we only need Qt instances for a certain lexical context of code. For this case, <code><a href="#QTOOLS:WITH-FINALIZING">with-finalizing</a></code> (and <code><a href="#QTOOLS:WITH-FINALIZING*">with-finalizing*</a></code>) can be used, which is a counterpart to <code><a href="http://l1sp.org/cl/let">let</a></code> that calls <code><a href="#QTOOLS:FINALIZE">finalize</a></code> on all its bindings once the form exits. This will take care of most cases. For cases where the instance may escape, or has to stay bound in a closure, there's <code><a href="#QTOOLS:WITH-GC-FINALIZED">with-gc-finalized</a></code>. This wraps the value of each binding in a <code><a href="#QTOOLS:GC-FINALIZED">gc-finalized</a></code> object. Using such a container, we can use Common Lisp's garbage collector to keep track of the references and, once the object is garbage collected it calls <code><a href="#QTOOLS:FINALIZE">finalize</a></code> on its inner value, ensuring proper removal. The <code><a href="#QTOOLS:WITH-GC-FINALIZED">with-gc-finalized</a></code> uses a <code><a href="http://l1sp.org/cl/symbol-macrolet">symbol-macrolet</a></code> to ensure that you don't have to worry about the boxing. However, if you manually use <code><a href="#QTOOLS:GC-FINALIZED">gc-finalized</a></code> objects, there's the <code><a href="#QTOOLS:MAKE-GC-FINALIZED">make-gc-finalized</a></code> and <code><a href="#QTOOLS:UNBOX">unbox</a></code> functions (with corresponding reader macros <code>#&gt;</code> and <code>#&lt;</code> in the <code>:qtools</code> read-table).</p> <p>While this kind of system takes care of a lot of cases, it's still not perfect and it may happen that you accidentally create a memory leak somewhere. I wish there was an easier way, but alas, life is difficult. You can try to solve this kind of situation by debugging Qtools and keeping track of which objects get finalized and which don't.</p> <p>Another occasional task is to copy an object instance. Qtools offers a <code><a href="#QTOOLS:COPY">copy</a></code> and <code>copy-using-class</code> methods which handle proper copying for a couple of Qt objects, but sadly by far not all. If you want to use the copying system for a class that isn't handled by Qtools by default, you can define your own using <code><a href="#QTOOLS:DEFINE-COPY-METHOD">define-copy-method</a></code>.</p> <p>Qtools will handle the printing of QObject instances as well and provides you with a mechanism of defining print methods for a qclass, just like you normally would for CL classes by <code><a href="http://l1sp.org/cl/print-object">print-object</a></code>. Simply use <code><a href="#QTOOLS:DEFINE-PRINT-METHOD">define-print-method</a></code>.</p> <h3>Widgets</h3> <p>Qt deals with widgets. As such, making everything associated with them simple and easy to use should be a primary objective. Qtools' widget system attempts to do exactly that. The central part to this is the <code><a href="#QTOOLS:DEFINE-WIDGET">define-widget</a></code> macro. This expands to a <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> with the following effects: It sets <code><a href="#QTOOLS:WIDGET-CLASS">widget-class</a></code> as the metaclass, sets the first item of the superclass list as the qt-superclass, and injects <code><a href="#QTOOLS:WIDGET">widget</a></code> as a superclass, if it isn't one already. This means that essentially you can use anything you could in a standard <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> without having to worry about the necessary default options.</p> <p>However, just with a single <code><a href="#QTOOLS:DEFINE-WIDGET">define-widget</a></code> you won't get far ahead. You still need to use CommonQt's way of declaring slots, signals, and overrides, which is quite cumbersome. You can do that of course, but there is a more convenient method, which is to use <code><a href="#QTOOLS:DEFINE-SLOT">define-slot</a></code>, <code><a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a></code>, and <code><a href="#QTOOLS:DEFINE-OVERRIDE">define-override</a></code>. These essentially translate to class options, albeit in a detached way. Each of these define statements is of the following syntax:</p> <pre><code>(define-* (<a href="#QTOOLS:WIDGET-CLASS">widget-class</a> name) arglist &amp;body body)
</code></pre> <p>Some of them take optional extra arguments in the name-list, such as a method-name in the case of <code><a href="#QTOOLS:DEFINE-SLOT">define-slot</a></code> and <code><a href="#QTOOLS:DEFINE-OVERRIDE">define-override</a></code>. In the case of <code><a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a></code> the body is discarded. However, even with these extensions things are rather cumbersome: You need to manually define slots for each of the widgets you want to use inside your widget class, and define their behaviour in an <code><a href="http://l1sp.org/cl/initialize-instance">initialize-instance</a></code> function. This is unwieldy, which is why Qtools also adds <code><a href="#QTOOLS:DEFINE-INITIALIZER">define-initializer</a></code>, <code><a href="#QTOOLS:DEFINE-FINALIZER">define-finalizer</a></code>, and <code><a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a></code>. The first two follow in signature to the above minus the <code>arglist</code> and do what you might expect them to do: handle initialization and finalization. The initializer and finalizer forms take an optional priority argument in their name-list. The higher, the sooner. <code><a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a></code> on the other hand looks like this:</p> <pre><code>(<a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a> (<a href="#QTOOLS:WIDGET-CLASS">widget-class</a> name) initform &amp;body body)
</code></pre> <p>And its effects are two-fold. First, it adds a finalized slot to the widget-class called name. Then, it adds an initializer (with priority 10) that sets the slot-value to the value of <code>initform</code> and then evaluates the <code>body</code> forms. This by itself takes care of the repetitive slot and initializer definition, but without an extra helper called <code><a href="#QTOOLS:WITH-SLOTS-BOUND">with-slots-bound</a></code>, it would still be annoying to write functions, as you would have to reference widgets using <code><a href="http://l1sp.org/cl/slot-value">slot-value</a></code> everywhere. <code><a href="#QTOOLS:WITH-SLOTS-BOUND">with-slots-bound</a></code> is like <code><a href="http://l1sp.org/cl/with-slots">with-slots</a></code>, but it binds <em>all</em> direct class-slot values to their respective slot names. Every <code>define-*</code> function's body is automatically wrapped in a <code><a href="#QTOOLS:WITH-SLOTS-BOUND">with-slots-bound</a></code>, to make this convenience possible.</p> <p>If you do not like this behaviour, due to potential symbol clashes and general confusion that might arise from the implicit action, you can instead use <code>cl+qt:defmethod</code> and <code><a href="http://l1sp.org/cl/declare">declare</a></code> statements. This is actually what all the <code>define-*</code> (with the exception of <code><a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a></code>) expand to: A <code>cl+qt:defmethod</code> with an appropriate declaration inserted into the body. The <code>cl+qt:defmethod</code> behaves exaclty like <code><a href="http://l1sp.org/cl/defmethod">cl:defmethod</a></code> with the exception of allowing the handling of custom declaration forms. Qtools defines the following declarations: <code><a href="#QTOOLS:SLOT">slot</a></code>, <code><a href="#QTOOLS:OVERRIDE">override</a></code>, <code><a href="#QTOOLS:INITIALIZER">initializer</a></code>, and <code><a href="#QTOOLS:FINALIZER">finalizer</a></code>. In the case of a <code><a href="#QTOOLS:SLOT">slot</a></code> definition, an extra declaration called <code><a href="#QTOOLS:CONNECTED">connected</a></code> is also available. The effects of the declarations are as you might expect, and have the following signatures:</p> <pre><code>(<a href="#QTOOLS:SLOT">slot</a> slot-name args)
(<a href="#QTOOLS:CONNECTED">connected</a> slot-name (signal-name &amp;rest args))
(<a href="#QTOOLS:OVERRIDE">override</a> &amp;optional method-name)
(<a href="#QTOOLS:INITIALIZER">initializer</a> &amp;optional (priority 0))
(<a href="#QTOOLS:FINALIZER">finalizer</a> &amp;optional (priority 0))
</code></pre> <p>The user may define additional declarations using <code><a href="#QTOOLS:DEFINE-METHOD-DECLARATION">define-method-declaration</a></code>.</p> <p>At this point it is useful to note about the general startup sequence of a widget. Once <code><a href="http://l1sp.org/cl/make-instance">make-instance</a></code> is called, it calls to <code><a href="http://l1sp.org/cl/initialize-instance">initialize-instance</a></code>. Qtools defines a primary method on this specialized on the widget class. It then immediately calls the next method (<code><a href="http://l1sp.org/cl/call-next-method">call-next-method</a></code>), followed by <code><a href="#QTOOLS:CONSTRUCT">construct</a></code> which should call <code>qt:new</code>, instantiating the C++ parts. Following that are the initializers in the order of their priority (highest goes first). This means that if you (for some reason) define an <code>:after</code> method on <code><a href="http://l1sp.org/cl/initialize-instance">initialize-instance</a></code> for your own widget, it will be run after all initializers have completed. For finalization it is the same: all finalizers are run before your own <code><a href="#QTOOLS:FINALIZE">finalize</a></code> method is run. However, if you define a <code>:before</code> method on <code><a href="#QTOOLS:FINALIZE">finalize</a></code> for your class, it will be run before the <code>:finalized</code> slots are finalized, otherwise all primary and <code>:after</code> methods should not access <code>:finalized</code> slots anymore. If you absolutely do need to do things before normal initialization or finalization, you can define an <code>:around</code> method.</p> <p>One last widget-related definition form is <code><a href="#QTOOLS:DEFINE-MENU">define-menu</a></code>, which is a very convenient way of specifying menus:</p> <pre><code>(<a href="#QTOOLS:DEFINE-MENU">define-menu</a> (my-widget File)
  (:item (&quot;Open...&quot; (ctrl o))
    (open-file))
  (:menu recent-files)
  (:separator)
  (:item (&quot;Save&quot; (ctrl s))
    (save-file))
  (:item (&quot;Save As...&quot; (ctrl alt s))
    (save-file NIL))
  (:menu &quot;Export&quot;
    (:item &quot;PNG&quot; (save-file NIL &quot;png&quot;)))
  (:separator)
  (:item (&quot;Quit&quot; (ctrl q))
    (#_close widget)))
</code></pre> <p>Out of the box, it supports <code>:item</code>, <code>:menu</code>, and <code>:separator</code> components. The item takes a name, which can be either a string for a label, a list of string and keyboard mnemonic, or a symbol indicating the class slot that contains the item widget, and it takes a body of forms to execute if the item is triggered. Menus take a name as a string and a body of components to contain, or a symbol indicating the slot that contains the menu widget. New components can be added with <code><a href="#QTOOLS:DEFINE-MENU-CONTENT-TYPE">define-menu-content-type</a></code>.</p> <p>If your widget has a Qt superclass to whose constructor you would like to pass certain arguments, you can do so by adding a method on <code><a href="#QTOOLS:CONSTRUCT">construct</a></code> that calls <code>qt:new</code> with the arguments you need. You can also use a shorthand to do the same by adding a <code>(:constructor ..)</code> option to your widget definition form. This expands to a <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> form that binds all slots (<code><a href="#QTOOLS:WITH-ALL-SLOTS-BOUND">with-all-slots-bound</a></code>) and otherwise just contains a call to <code>qt:new</code> supplying the arguments of the option form verbatim. In effect this means that any unquoted symbol in the option denotes a slot reference. Note that the call to <code><a href="#QTOOLS:CONSTRUCT">construct</a></code> happens before the widget initializers are run. Thus you will not be able to use slot values that are set by subwidgets or initializers.</p> <p>As a final touch, Qtools offers macros for connecting slots and emitting signals. These translate to CommonQt's <code>emit-signal</code> and <code>connect</code> functions, and thus just offer a bit of syntactic sugar. They're called <code><a href="#QTOOLS:SIGNAL!">signal!</a></code> and <code><a href="#QTOOLS:CONNECT!">connect!</a></code>. Their use is simple enough:</p> <pre><code> (<a href="#QTOOLS:CONNECT!">connect!</a> input (text-edited string) widget (text-changed string))
 (<a href="#QTOOLS:SIGNAL!">signal!</a> input (text-edited string) &quot;Eyyyy&quot;)
</code></pre> <p>An experimental variant for the adventurous is <code><a href="#QTOOLS:GENERIC-SIGNAL">generic-signal</a></code>, which attempts to determine the argument types by their values at run-time. It does therefore not require specifying the type explicitly, but might instead screw up and choose a wrong type for the signal and thus fail to emit.</p> <h3>Q+</h3> <p>By default with CommonQt, calling Qt methods happens with the <code>#_</code> reader macro. This requires you to follow the proper case of the class and method names. Having this kind of mixture of conventions in the code is a bit jarring. While Qtools offers solutions to deal with the discrepancies of defining your own classes and widgets using the various <code>define-*</code> macros, Q+ fixes the method calling discrepancy. In order to use Q+ you have a choice of either using the <code><a href="#QTOOLS:Q+">q+</a></code> macro, or using the <code>:qtools</code> read-table. Using the <code><a href="#QTOOLS:Q+">q+</a></code> macro directly an example translates like this:</p> <pre><code>(<a href="http://l1sp.org/cl/let">let</a> ((widget (#_new QWidget)))
  (#_setWindowTitle widget &quot;Hello!&quot;)
  (#_show widget)
  (#_exec *qapplication*))

(<a href="http://l1sp.org/cl/let">let</a> ((widget (<a href="#QTOOLS:Q+">q+</a> make-qwidget)))
  (<a href="#QTOOLS:Q+">q+</a> set-window-title widget &quot;Hello!&quot;)
  (<a href="#QTOOLS:Q+">q+</a> show widget)
  (<a href="#QTOOLS:Q+">q+</a> exec *qapplication*))
</code></pre> <p>And the same using the readtable:</p> <pre><code>(<a href="http://l1sp.org/cl/let">let</a> ((widget (q+:make-qwidget)))
  (q+:set-window-title widget &quot;Hello!&quot;)
  (q+:show widget)
  (q+:exec *qapplication*))
</code></pre> <p>The difference is minimal in the typed code. However, the second approach will give you the convenience of letting the editor display the possible arguments and a docstring linking to the Qt methods. The second example is read by the Common Lisp reader to the first example. There is therefore no code difference in how the two work. If you use the <code>cl+qt</code> package, you can also take advantage of an extended <code><a href="http://l1sp.org/cl/setf">setf</a></code> macro. Using it, the second line would look like so:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#QTOOLS:Q+">q+</a> window-title widget) &quot;Hello!&quot;)
</code></pre> <p>Some of the setter functions require multiple values to be set at once. The updated <code><a href="http://l1sp.org/cl/setf">setf</a></code> can also deal with that:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#QTOOLS:Q+">q+</a> window painter) (<a href="http://l1sp.org/cl/values">values</a> 0 0 100 100))
</code></pre> <p>The <code><a href="http://l1sp.org/cl/setf">setf</a></code> has extra support for <code><a href="#QTOOLS:Q+">q+</a></code>, but is otherwise identical to <code><a href="http://l1sp.org/cl/setf">cl:setf</a></code> and actually expands to that for all other places.</p> <p>In order to access enum values, you simply use the class name followed by a dot and the enum name. Constructors are the class name prefixed with &quot;make&quot;. Static functions are the class name, a dash, and the method name in the standard translation scheme.</p> <pre><code>(q+:qt.blue)
(q+:make-qpushbutton &quot;Foo!&quot;)
(q+:qmessagebox-information parent &quot;!&quot; &quot;hello!&quot;)
</code></pre> <p>For the specific arguments, names, and everything else, refer to the <a href="http://qt-project.org/doc/qt-4.8/">Qt4.8</a> documentation. It's very good, trust me. The only thing you need to be aware of is the name conversion rules that Q+ uses to determine the proper Lisp symbol to use:</p> <ul> <li>Method <code>QImage::constScanLine</code> =&gt; <code>q+:const-scan-line</code></li> <li>Method <code>Foo::set_widget</code> =&gt; <code>q+:set_widget</code></li> <li>Constant <code>QImage::InvertRgb</code> =&gt; <code>q+:qimage.invert-rgb</code></li> <li>Constant <code>QImage::Format_ARGB32_Premultiplied</code> =&gt; <code>q+:qimage.format_argb32_premultiplied</code></li> <li>Static Method <code>QFileDialog::getExistingDirectory</code> =&gt; <code>q+:qfiledialog-get-existing-directory</code></li> <li>Constructor <code>QImage::QImage</code> =&gt; <code>q+:make-qimage</code></li> </ul> <p>For Q+ to work seamlessly in conjunction with ASDF systems and compiling/loading code, you have to make sure that the smoke modules are set up correctly.</p> <p><code><a href="#QTOOLS:Q+">q+</a></code> and the reader extension dynamically compile wrapper functions for the Qt methods you access. You can, however, also precompile all possible methods for the currently active set of smoke modules. To do this, you can either <code>:depends-on (:q+)</code> or compile a source file using <code><a href="#QTOOLS:WRITE-EVERYTHING-TO-FILE">write-everything-to-file</a></code> and include it in your ASDF system. If you choose this approach, you will not need to switch the readtable or use the <code><a href="#QTOOLS:Q+">q+</a></code> macro, as the package will be available fully populated.</p> <h3>Smoke Modules</h3> <p>In order to be able to use the various parts of Qt, the corresponding smoke modules need to be loaded. By default CommonQt loads <code>qtcore</code> and <code>qtgui</code> when <code>make-qapplication</code> is called. However, if you want to use, say, the OpenGL parts you'll also need <code>qtopengl</code>.</p> <p>Qtools provides ASDF systems for all the different smoke modules. That way, you can simply push the modules you want into your project's ASDF system dependencies and it'll ensure that the modules are available at compile and load time. Having the modules loaded at both times is especially important for Q+ to work properly. An example system making use of this would look like</p> <pre><code>(asdf:defsystem foo
  ...
  :depends-on (:qtcore :qtgui))
</code></pre> <p>For a list of available smoke modules, see <code><a href="#QTOOLS:*SMOKE-MODULES*">*smoke-modules*</a></code>.</p> <h3>Fast Calling</h3> <p>In some cases it is vital to minimise overhead to a method call. Since usually dispatch is dynamic at run-time and un/marshalling of arguments and return values is involved, the standard way of calling methods might be too slow. In that case, you can use Qtools' fast-call mechanism to perform a method call as quickly as possible. At a cost, naturally.</p> <pre><code>(<a href="http://l1sp.org/cl/let">let</a> ((size (q+:make-qsize 100 100)))
  (<a href="#QTOOLS:FAST-CALL">fast-call</a> (set-height QSize int) size 200)
  size)
</code></pre> <p>Fast-calling is possible if you know the exact method signature to call and are willing to translate the arguments to their proper required CFFI types. In the case of passing QObjects, you must pass their pointer. You can get that pointer by <code>qt::qobject-pointer</code>.</p> <h2>Examples</h2> <p>A couple of example applications using Qtools can be found in the <a href="https://github.com/Shinmera/qtools/tree/master/examples/">examples/</a> folder: <code>qtools-evaluator</code>, <code>qtools-titter</code>, <code>qtools-melody</code>, and <code>qtools-opengl</code>. Each of them can be loaded by their name, and launched using the <code>main</code> function from their package.</p> <h2>Extending Qtools</h2> <h3>Copying and Finalizing</h3> <p>In order to account for your own objects and operations you can extend the <code><a href="#QTOOLS:COPY">copy</a></code> and <code><a href="#QTOOLS:FINALIZE">finalize</a></code> functions by using <code><a href="#QTOOLS:DEFINE-COPY-METHOD">define-copy-method</a></code> and <code><a href="#QTOOLS:DEFINE-FINALIZE-METHOD">define-finalize-method</a></code> or <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> directly. The two define macros bring the convenience of automatically resolving to a Qt class (and thus using <code>copy/finalize-using-class</code>) if possible, making it all look a bit cleaner.</p> <pre><code>(<a href="#QTOOLS:DEFINE-COPY-METHOD">define-copy-method</a> (instance QPixmap)
  &quot;Creates a new QPixmap using QPixmap::copy (deep copy).&quot;
  (#_copy instance (#_rect instance)))
</code></pre> <p>Since copying and finalizing are operations associated with a certain amount of ambiguity, it is advisable to always write documentation strings for your <code><a href="#QTOOLS:COPY">copy</a></code>/<code><a href="#QTOOLS:FINALIZE">finalize</a></code> methods. That way users can get a better idea of what will happen by reading about it using <code><a href="#QTOOLS:DESCRIBE-COPY-METHOD">describe-copy-method</a></code> and <code><a href="#QTOOLS:DESCRIBE-FINALIZE-METHOD">describe-finalize-method</a></code> respectively.</p> <h3>Adding <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> declarations</h3> <p>Using <code><a href="#QTOOLS:DEFINE-METHOD-DECLARATION">define-method-declaration</a></code> you can add your own processing to method declarations. Your function should extract the necessary information from its declaration arguments and the <code><a href="#QTOOLS:*METHOD*">*method*</a></code> form. Each method declaration processing function should return a single form (like a macro) to be put before the resulting <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code>. The existing declaration processors are really short:</p> <pre><code>(<a href="#QTOOLS:DEFINE-METHOD-DECLARATION">define-method-declaration</a> override (<a href="http://l1sp.org/cl/&amp;optional">&amp;optional</a> name)
  (<a href="http://l1sp.org/cl/let">let</a> ((slot (<a href="#QTOOLS:TO-METHOD-NAME">qtools:to-method-name</a> (<a href="http://l1sp.org/cl/or">or</a> name (form-fiddle:lambda-name *method*)))))
    (<a href="#QTOOLS:WITH-WIDGET-CLASS">with-widget-class</a> (<a href="#QTOOLS:WIDGET-CLASS">widget-class</a>)
      `(<a href="#QTOOLS:SET-WIDGET-CLASS-OPTION">set-widget-class-option</a> ',widget-class :override '(,slot ,name)))))
</code></pre> <p>In this example we're using <a href="http://github.com/Shinmera/form-fiddle">form-fiddle</a> to parse the method form. Using a library like that to ensure proper destructuring is important, as otherwise it's easy to accidentally butcher the method form, or get the wrong information.</p> <h3>Extending the menu definition</h3> <p>The menu definition form allows for arbitrary content types, so you may add new ones yourself by using <code><a href="#QTOOLS:DEFINE-MENU-CONTENT-TYPE">define-menu-content-type</a></code>. Each content type definition can return two values: an initform and a side-form. The initform will be put into the initialization function for the menu and thus evaluated when the widget is created. The side-form is put alongside the initializer definition and thus evaluated during compilation. If your menu type needs to modify the widget class in some way, that should be done through the side-forms. If it needs to connect signals, add items, or perform similar actions that involve Qt, that should go into the initform. You can call the expansion of other component types using <code><a href="#QTOOLS:BUILD-MENU-CONTENT">build-menu-content</a></code>. During the time your content-type function is run, <code><a href="#QTOOLS:*WIDGET*">*widget*</a></code> is bound to the class-name of the widget and during initialization it is bound to the actual widget instance.</p> <h2>Debugging Qtools</h2> <p>Since Qtools does a bunch of contrived things, you might want to check what exactly is done if something doesn't go according to plan. I'm not excluding the possibility of bugs being around that mess your code up. In order to check this, you will want to load <a href="http://shinmera.github.io/verbose/">verbose</a> before loading Qtools and set the logging level to trace: <code>(<a href="http://l1sp.org/cl/setf">setf</a> (v:repl-level) :trace)</code>. Qtools will emit log messages when you compile <code><a href="#QTOOLS:DEFINE-WIDGET">define-widget</a></code> forms that contain the generated options. It will also log all objects that get passed to <code><a href="#QTOOLS:FINALIZE">finalize</a></code> and <code><a href="#QTOOLS:COPY">copy</a></code>. Hopefully the log output will help you in discovering what's going on behind the scenes.</p> <h2>Qtools Concepts</h2> <p>Qtools has grown to be a large library with a lot of rather complicated concepts. I will try to describe them here, in order to retain some information in non-code form and make things clearer to the average user. It is not necessary to read and understand this section to use Qtools, but it may be useful to be aware of the underlying ideas and functionality that make Qtools work.</p> <h3>Finalizables</h3> <p>A finalizable is implemented using two classes, one serving as the metaclass and the other as a superclass. The metaclass is required in order to allow a custom slot type that supports the <code>:finalized</code> argument. The superclass is necessary in order to allow methods such as <code><a href="#QTOOLS:FINALIZE">finalize</a></code> to operate on instances of the finalizable classes. The handling of the finalized slots is done through a general method on <code><a href="#QTOOLS:FINALIZE">finalize</a></code> that scans through the slots of the class instance and then calls <code><a href="#QTOOLS:FINALIZE">finalize</a></code> on each slot for which the definition is set to be <code>:finalized</code>. This makes finalization of class slots automatic and convenient.</p> <p>Since finalizables don't add any metaclass properties, there is no need to manually calculate inheritance order. However, as with all custom slot definitions, the slot properties must be copied over from the direct-slot instance to the effective slot. In the case of <code><a href="#QTOOLS:FINALIZABLE-CLASS">finalizable-class</a></code> this happens in <code>compute-effective-slot-definition</code>.</p> <p>In order to support finalizing of Qt class instances that don't have a CL class equivalent, the <code><a href="#QTOOLS:FINALIZE">finalize</a></code> method is extended wit ha <code>finalize-using-class</code> that is dispatched to using the Qt class and the instance of a <code>qobject</code> instance is passed to <code><a href="#QTOOLS:FINALIZE">finalize</a></code>.</p> <h3>Widgets</h3> <p>As with finalizables, the widget is implemented using two classes, the <code><a href="#QTOOLS:WIDGET-CLASS">widget-class</a></code> metaclass and the <code><a href="#QTOOLS:WIDGET">widget</a></code> superclass. These both inherit from the finalizable equivalents. The main crux of the <code><a href="#QTOOLS:WIDGET-CLASS">widget-class</a></code> lies in its <code><a href="#QTOOLS:WIDGET-CLASS-DIRECT-OPTIONS">widget-class-direct-options</a></code> and <code><a href="#QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS">widget-class-extern-options</a></code>. The direct options are the options that are passed to a <code>re/</code> <code><a href="http://l1sp.org/cl/initialize-instance">initialize-instance</a></code> (and thus also to <code><a href="http://l1sp.org/cl/defclass">defclass</a></code>). They're caught in the appropriately specialised methods and then stored on the class. The effect of this is that we can fully recompute the class definition at any time, and potentially add or remove options without influencing the original <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> statement. This is where the extern-options come in.</p> <p>Using <code><a href="#QTOOLS:SET-WIDGET-CLASS-OPTION">set-widget-class-option</a></code> options can be added to the class definition dynamically at any point in the program. This function then adds the option to the class' extern-options and then calls <code><a href="http://l1sp.org/cl/reinitialize-instance">reinitialize-instance</a></code>, which in turn causes the class to get effectively redefined outside of its <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> form. This redefinition also allows us to change CommonQt class options. Using this we can create forms outside of the original <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> that act as if they were actually options in the <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> form.</p> <p>Qtools effectively only provides two forms that do this: <code><a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a></code> and <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code>. The <code><a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a></code> is relatively straightforward and simply expands to a class option set to add a new signal option. The <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> is an extensible machine in itself.</p> <p>What's special about the <code>cl+qt:defmethod</code> is that it inspects the declaration forms in the method body. It then checks for each declaration form whether a handler function exist and if so, calls that function. Such a <code><a href="#QTOOLS:METHOD-DECLARATION">method-declaration</a></code> function can then return forms to be put into the macroexpansion of the <code>cl+qt:defmethod</code>, before the resulting <code><a href="http://l1sp.org/cl/defmethod">cl:defmethod</a></code>. The processed declaration is then left out of the <code><a href="http://l1sp.org/cl/defmethod">cl:defmethod</a></code>form as it is assumed that it isn't a standard common lisp declaration. However, the declaration function also has the ability to change the contents of the <code><a href="http://l1sp.org/cl/defmethod">cl:defmethod</a></code> form itself, by manipulating <code><a href="#QTOOLS:*METHOD*">*method*</a></code>. This allows the declaration to output special handling for the method body, for example.</p> <p>This kind of extensible declaration mechanism is necessary both to allow further evolving of Qtools in the future as well as adaptation by users. It also offers a very &quot;native-like&quot; way of specifying external effects of a method. Qtools uses this construct then to allow definition of slots, overrides, finalizers, and initializers.</p> <p>In case the user doesn't appreciate the <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> way, Qtools then provides <code>define-*</code> alternative functions that simply wrap over <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code>, establish some default bindings, and take care of naming and specialising the method.</p> <p>The <code><a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a></code> deserves special attention here, as it does more work than the rest. A large part of defining widgets is adding sub-components to it, which is a task that usually involves a lot of repetition or awkward function sharing: Setting up a slot to hold the instance, defining or using an initializer to set it up. <code><a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a></code> makes this both distributed and simple by both taking care of setting up an appropriate initializer function, and automatically adding the slot to the class using, again, <code><a href="#QTOOLS:SET-WIDGET-CLASS-OPTION">set-widget-class-option</a></code>. This slot is also always automatically set to be <code><a href="#QTOOLS:FINALIZED">finalized</a></code> in order to ensure that all widgets are properly cleaned up when the GUI is no longer needed.</p> <p>A minor problem regarding this approach is the same problem that appears with all of CL's definition forms. While developing incrementally, merely removing the definition form from the source file, will not actually remove it from the image. This can trip developers up, as definitions will still be active later. In this case it means having widgets still sticking around, or initializers running, etc. For this purpose there are corresponding <code>remove-*</code> functions to all the <code>define-*</code> functions to allow easy removal. This part cannot possibly be automated due to the nature of Common Lisp, but it is at least simple to correct should the need arise.</p> <h3>Q+</h3> <p>CommonQt's way of dealing with method calls is the simple and most direct way of doing it. The first possible alternative to remove the need for typing method names in their corresponding case would be to simply introduce a different reader macro that automatically translates a <code>example-function</code>-like name into <code>exampleFunction</code> as is done already in other parts of Qtools. However, this has two downsides, the first being that there does not exist a 1:1 mapping of methods anywhere. The dynamic computation of the function name means that there isn't a full correspondence table anywhere. The second downside is that methods are still not passable as first-class objects.</p> <p>The way to solve this is to generate actual CL wrapper functions to the method calls. This allows us to use them as first-class objects, have at least compile-time argument number checking, and have a linkage of wrapper name to Qt method by listing it in the docstring.</p> <p>In order to achieve this, there are two possible choices. First, the entirety of all possible wrappers can be computed once, and then subsequently loaded into the image and used directly. However, this creates two new problems. Computing all wrappers, compiling them, and loading them, takes a long time and subsequently litters the image with thousands of functions and symbols that won't ever be used in the program. Then, we have a problem with the smoke modules, as we need to know which modules will be used in a potential application ahead of time, load them all, and then generate the wrappers. We cannot generate wrappers for each module separately, as the methods from different classes share the same wrapper functions. This means that whenever a different set of modules is needed, the wrappers need to be regenerated, recompiled, and reloaded. A lot of time and space goes to waste with this. However, this approach also has an advantage: As all functions are always available, it is easy to develop with. Arguments and docstrings will be readily available through the editor. Qtools offers this approach through <code><a href="#QTOOLS:Q+-COMPILE-AND-LOAD">q+-compile-and-load</a></code>.</p> <p>The second approach is to dynamically only compile what is needed. That way, the image only ever contains wrappers for function that are actually called (at some point). However, this complicates things a lot. When a function is compiled that calls such a function, it doesn't exist yet. Even worse, when the form is read, the symbol for the function does not exist yet and isn't external! In order to catch this problem, a modified reader macro is necessary. This reader macro will detect when a call to a wrapper function is made, and instead transform it into a macro call that then sees to it that the wrapper will be created. Modifying the reader in such a way is a heavy change, and should only be used sparingly, however there is no alternative here. Qtools does not force you to use this reader extension, you can always just use the macro directly.</p> <p>However, dynamic compilation complications don't end there. Since we never dump the function to a file, it only ever exists in the environment it was compiled in. That means, if you compile a function that then dynamically generates the wrapper function, the wrapper won't be available anymore at load time. Qtools solves this issue with a trick. The <code><a href="#QTOOLS:Q+">q+</a></code> macro expands to a <code><a href="http://l1sp.org/cl/load-time-value">load-time-value</a></code> form that then generates the wrapper function. That way, the wrapper will always be available at load- and execution time, while posing no overhead to the execution time, as it will return a value to that won't impact anything.</p> <p>Function referencing gets the same problems as function calling, so the Qtools readtable also contains an overridden <code>#'</code> reader macro to handle that. In the case of a wrapper call, it expands to <code><a href="#QTOOLS:Q+FUN">Q+FUN</a></code> which in turn expands to a <code><a href="http://l1sp.org/cl/load-time-value">load-time-value</a></code> form that generates and returns the function object.</p> <p>As is probably obvious by now, Qtools also implements the second approach. Therefore, the choice as a user is yours: You can statically precompile everything and use it directly, or you an use the dynamic on the fly compilation using either a readtable expansion, or a simple macro. The concepts to make this all possible are rather complex, but the actual function wrapper compilations are quite straight-forward. The system is currently not suited for extension, but I see no need to allow that as the kind of Qt methods that can exist are fixed and Q+ should handle all that are relevant.</p> <p>Q+ does one last thing to fix the &quot;issue&quot; of having setters instead of being able to use <code><a href="http://l1sp.org/cl/setf">setf</a></code>. For this purpose it has an extended <code><a href="http://l1sp.org/cl/setf">setf</a></code> macro that checks if a place is a function in the Q+ package. if so, this place/value pair is instead expanded to a call to the appropriate wrapper function with the function name transformed. However, that's not the only reason to do this. The second is that some setters require multiple arguments to be set at once. Usually, <code><a href="http://l1sp.org/cl/setf">cl:setf</a></code> allows for cases like these by permitting setf expanders to accept multiple values. However, the number of values is fixed, and there's no way to dynamically know how many values where passed. Since Q+ needs to dispatch based on the number of values, this is not a viable approach. Therefore, with <code>cl+qt:setf</code> a <code>(<a href="http://l1sp.org/cl/values">values</a> ..)</code> value form is specially treated and its arguments are inlined into the wrapper call. This also means that it isn't possible to use multiple values of a returning function as the values to a setter call, however while that is an inconsistency, I don't think it will be a big issue. If it turns out to be problematic in the later run, this will have to be changed to a dynamic analysis at run-time, which is an overhead I wanted to avoid.</p> <h2>Support</h2> <p>Currently the following implementations are tested and supported by Qtools:</p> <ul> <li><a href="http://www.sbcl.org/">SBCL</a></li> <li><a href="http://ccl.clozure.com/">CCL</a></li> <li><a href="https://common-lisp.net/project/ecl/">ECL</a></li> </ul> <p>You can run it on x86_64 Linux, OS X, and Windows, where SBCL on Linux is the recommended platform.</p> <p>It may or may not work more or less smoothly on other implementations and platforms depending on MOP and CommonQt support and general implementation quirks.</p> </div>  </article> <article id="copyright">  <h2>Copyright</h2> <span>qtools</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=Artistic">Artistic</a></span> license.  © <span>Nicolas Hafner &lt;shinmera@tymoon.eu&gt;</span> .  This library can be obtained on <a href="https://github.com/Shinmera/qtools">https://github.com/Shinmera/qtools</a>.  </article>  <article id="symbol-index"> <h2>Package Index</h2> <ul><li class="package"> <h3> <a name="QTOOLS" href="#QTOOLS">QTOOLS</a> <span class="nicknames">(ORG.SHIRAKUMO.QTOOLS)</span> </h3> <ul><li> <a name="QTOOLS:*BOOT-HOOKS*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*BOOT-HOOKS*">*BOOT-HOOKS*</a></code></h4>  </header> <div class="docstring"><pre>A list of functions to invoke (in sequence) during the warm-boot.

Use this to run customised startup, prepare, or load functions.</pre></div> </article> </li><li> <a name="QTOOLS:*BUILD-HOOKS*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*BUILD-HOOKS*">*BUILD-HOOKS*</a></code></h4>  </header> <div class="docstring"><pre>A list of functions to invoke (in sequence) during the build.

Use this to run customised cleanup, compile, or deployment functions.</pre></div> </article> </li><li> <a name="QTOOLS:*DEPLOYMENT-LOCATION*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*DEPLOYMENT-LOCATION*">*DEPLOYMENT-LOCATION*</a></code></h4>  </header> <div class="docstring"><pre>Variable containing the path to the directory that is being deployed to.

This is bound when *BOOT-HOOKS* functions are called.</pre></div> </article> </li><li> <a name="QTOOLS:*GENERATED-MODULES*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*GENERATED-MODULES*">*GENERATED-MODULES*</a></code></h4>  </header> <div class="docstring"><pre>A list of loaded smoke modules when PROCESS-ALL-METHODS is called.
This is useful to keep track over environments which modules are
actually available for compilation.</pre></div> </article> </li><li> <a name="QTOOLS:*METHOD*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*METHOD*">*METHOD*</a></code></h4>  </header> <div class="docstring"><pre>Contains the whole DEFMETHOD form that is currently being processed.
If you modify the contents of this variable, the changes will be reflected
in the outputted method definition form. However, no declaration that is
processed by method-declarations will ever appear in the output.</pre></div> </article> </li><li> <a name="QTOOLS:*OPERATOR-MAP*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*OPERATOR-MAP*">*OPERATOR-MAP*</a></code></h4>  </header> <div class="docstring"><pre>A hash-table of C++ operators to CL function names.</pre></div> </article> </li><li> <a name="QTOOLS:*QMETHODS*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*QMETHODS*">*QMETHODS*</a></code></h4>  </header> <div class="docstring"><pre>Table mapping a *TARGET-PACKAGE* symbol to a list of
associated Qt methods. This table should only be changed
by PROCESS-METHOD. If you modify yourself without knowing
exactly what you're doing you'll most likely run into problems.

Methods/functions contained in this table are available
for compilation.

See <a href="#QTOOLS:PROCESS-METHOD">QTOOLS:PROCESS-METHOD</a>
See <a href="#QTOOLS:COMPILE-WRAPPER">QTOOLS:COMPILE-WRAPPER</a></pre></div> </article> </li><li> <a name="QTOOLS:*QT-CLASS-MAP*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*QT-CLASS-MAP*">*QT-CLASS-MAP*</a></code></h4>  </header> <div class="docstring"><pre>An EQUALP hash-table of all Qt4.8 class names to themselves as strings.</pre></div> </article> </li><li> <a name="QTOOLS:*QT-CLASS-VECTOR*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*QT-CLASS-VECTOR*">*QT-CLASS-VECTOR*</a></code></h4>  </header> <div class="docstring"><pre>A vector of all Qt4.8 class names as strings.</pre></div> </article> </li><li> <a name="QTOOLS:*QUIT-HOOKS*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*QUIT-HOOKS*">*QUIT-HOOKS*</a></code></h4>  </header> <div class="docstring"><pre>A list of functions to invoke (in sequence) when the program quits.

Use this to run customised saving or cleanup functions.</pre></div> </article> </li><li> <a name="QTOOLS:*SMOKE-MODULES*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*SMOKE-MODULES*">*SMOKE-MODULES*</a></code></h4>  </header> <div class="docstring"><pre>A list of all possible smoke modules.

These modules provide the C wrappers required to work with
the respective Qt parts. Usually you will only need
QTCORE and QTGUI, but for example if you need OpenGL support
you'll want QTOPENGL, or if you need phonon, you'll want
the PHONON module.</pre></div> </article> </li><li> <a name="QTOOLS:*SMOKE-MODULES-TO-RELOAD*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*SMOKE-MODULES-TO-RELOAD*">*SMOKE-MODULES-TO-RELOAD*</a></code></h4>  </header> <div class="docstring"><pre>A list of smoke modules that need to be reloaded on boot.

The system sets this variable itself during the build.</pre></div> </article> </li><li> <a name="QTOOLS:*TARGET-PACKAGE*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*TARGET-PACKAGE*">*TARGET-PACKAGE*</a></code></h4>  </header> <div class="docstring"><pre>The package used to store Qt wrapper functions that the Q+ system uses.
By default this package is called &quot;Q+&quot;. The package should not contain
any systems except for those generated by Qtools.</pre></div> </article> </li><li> <a name="QTOOLS:*WIDGET*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#QTOOLS:*WIDGET*">*WIDGET*</a></code></h4>  </header> <div class="docstring"><pre>Bound to the class-name of the widget during component expansion and
bound to the class instance during initialization.</pre></div> </article> </li><li> <a name="QTOOLS:CLASS"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#QTOOLS:CLASS">CLASS</a></code></h4>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:FINALIZABLE"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#QTOOLS:FINALIZABLE">FINALIZABLE</a></code></h4>  </header> <div class="docstring"><pre>A class for finalizable objects.</pre></div> </article> </li><li> <a name="QTOOLS:FINALIZABLE-CLASS"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#QTOOLS:FINALIZABLE-CLASS">FINALIZABLE-CLASS</a></code></h4>  </header> <div class="docstring"><pre>Metaclass for classes with finalizable slots.</pre></div> </article> </li><li> <a name="QTOOLS:FINALIZABLE-SLOT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#QTOOLS:FINALIZABLE-SLOT">FINALIZABLE-SLOT</a></code></h4>  </header> <div class="docstring"><pre>Superclass for slots with a finalized option.</pre></div> </article> </li><li> <a name="QTOOLS:GC-FINALIZED"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#QTOOLS:GC-FINALIZED">GC-FINALIZED</a></code></h4>  </header> <div class="docstring"><pre>Wrapper object to allow automatic calling of FINALIZE by the GC.
Since you cannot finalize the object that is GC-ed itself, we need to wrap our to-
be-finalized object in another object that takes all the references instead.

This means that if you wish your object to remain unfinalized, you need to retain
references to the wrapper. As soon as the wrapper is hit by the GC, FINALIZE is
called on the object it contains.

In order to retrieve the contained object, use UNBOX.</pre></div> </article> </li><li> <a name="QTOOLS:QT-PROGRAM-OP"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#QTOOLS:QT-PROGRAM-OP">QT-PROGRAM-OP</a></code></h4>  </header> <div class="docstring"><pre>A DEPLOY:DEPLOY-OP subclass to handle things for Qt deployment.

You should specify this as the BUILD-OPERATION in your ASD along with
an ENTRY-POINT and a BUILD-PATHNAME.</pre></div> </article> </li><li> <a name="QTOOLS:SMOKE-MODULE-SYSTEM"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#QTOOLS:SMOKE-MODULE-SYSTEM">SMOKE-MODULE-SYSTEM</a></code></h4>  </header> <div class="docstring"><pre>A wrapper ASDF system class that only exists to ensure that a
given smoke module is loaded at compile and load time.</pre></div> </article> </li><li> <a name="QTOOLS:WIDGET"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#QTOOLS:WIDGET">WIDGET</a></code></h4>  </header> <div class="docstring"><pre>Common superclass for all widgets in order to allow for
general initialization and cleanup forms that are standardised across all
widgets. 

See <a href="#QTOOLS:DEFINE-WIDGET.">QTOOLS:DEFINE-WIDGET.</a></pre></div> </article> </li><li> <a name="QTOOLS:WIDGET-CLASS"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#QTOOLS:WIDGET-CLASS">WIDGET-CLASS</a></code></h4>  </header> <div class="docstring"><pre>Metaclass for widgets storing necessary information.

The metadata stored in this is mostly responsible for two things:
 1) Providing access to a sequence of mutually independent
    initializers and finalizers for convenient setup and cleanup.
 2) Allowing after-the-fact out-of-form changes to the class
    definition, which is necessary to have for a distributed
    definition form syntax as provided by WIDGET-CONVENIENCE macros.
In order to modify the metadata, please look at SET/REMOVE-WIDGET-CLASS-OPTION.</pre></div> </article> </li><li> <a name="QTOOLS:COMPILATION-NOTE"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#QTOOLS:COMPILATION-NOTE">COMPILATION-NOTE</a></code></h4>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:INVALID-QT-SUPERCLASS-HIERARCHY"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#QTOOLS:INVALID-QT-SUPERCLASS-HIERARCHY">INVALID-QT-SUPERCLASS-HIERARCHY</a></code></h4>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:CLASHING-QT-SUPERCLASS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:CLASHING-QT-SUPERCLASS">CLASHING-QT-SUPERCLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:CLASHING-SUPERCLASS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:CLASHING-SUPERCLASS">CLASHING-SUPERCLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:MENU-CONTENT-TYPE"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:MENU-CONTENT-TYPE">MENU-CONTENT-TYPE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME</code><code>)</code>  </header> <div class="docstring"><pre>Returns the function to process a menu content type NAME, if any.</pre></div> </article> </li><li> <a name="QTOOLS:METHOD-DECLARATION"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:METHOD-DECLARATION">METHOD-DECLARATION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME</code><code>)</code>  </header> <div class="docstring"><pre>Returns a function to process the method declaration NAME, if one exists.

See <a href="NIL">(SETF</a> QTOOLS:METHOD-DECLARATION).</pre></div> </article> </li><li> <a name="QTOOLS:PARENT"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:PARENT">PARENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>accesses the PARENT of the object. This usually translates to (#_parent object) unless overridden.</pre></div> </article> </li><li> <a name="QTOOLS:REQUESTED-QT-SUPERCLASS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REQUESTED-QT-SUPERCLASS">REQUESTED-QT-SUPERCLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:VALUE"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:VALUE">VALUE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accesses the VALUE of the object. This usually translates to (#_value object) unless overridden.</pre></div> </article> </li><li> <a name="QTOOLS:WIDGET-ACTIONS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WIDGET-ACTIONS">WIDGET-ACTIONS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Returns a list of QAction instances that are active on the given CLASS.</pre></div> </article> </li><li> <a name="QTOOLS:WIDGET-CLASS-DIRECT-OPTIONS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WIDGET-CLASS-DIRECT-OPTIONS">WIDGET-CLASS-DIRECT-OPTIONS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Contains all the options passed to RE/INITIALIZE-INSTANCE when
the class is re/initialized directly through a DEFCLASS form.</pre></div> </article> </li><li> <a name="QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS">WIDGET-CLASS-EXTERN-OPTIONS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Contains all the options that are added to the class definition
through external forms and thus need to be included and kept separate
from options directly specified in the class definition.</pre></div> </article> </li><li> <a name="QTOOLS:WIDGET-CLASS-FINALIZERS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WIDGET-CLASS-FINALIZERS">WIDGET-CLASS-FINALIZERS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>A sorted list of functions to be called upon finalization.
This list is overwritten completely whenever the class is re/initialized.

See <a href="#QTOOLS:CALL-FINALIZERS">QTOOLS:CALL-FINALIZERS</a></pre></div> </article> </li><li> <a name="QTOOLS:WIDGET-CLASS-INITIALIZERS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WIDGET-CLASS-INITIALIZERS">WIDGET-CLASS-INITIALIZERS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>A sorted list of functions to be called upon initialization.
This list is overwritten completely whenever the class is re/initialized.

See <a href="#QTOOLS:CALL-INITIALIZERS">QTOOLS:CALL-INITIALIZERS</a></pre></div> </article> </li><li> <a name="QTOOLS:BUILD-MENU-CONTENT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:BUILD-MENU-CONTENT">BUILD-MENU-CONTENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">PARENT TYPE CONTENTS</code><code>)</code>  </header> <div class="docstring"><pre>Calls the appropriate function to parse menu content of TYPE.

See <a href="NIL">(SETF</a> QTOOLS:MENU-CONTENT-TYPE).</pre></div> </article> </li><li> <a name="QTOOLS:CALL-FINALIZERS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:CALL-FINALIZERS">CALL-FINALIZERS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Calls all the finalizers specified on CLASS in their proper sequence.

CLASS can be either an instance of a WIDGET-CLASS, a
WIDGET-CLASS itself, or a symbol naming the class.</pre></div> </article> </li><li> <a name="QTOOLS:CALL-INITIALIZERS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:CALL-INITIALIZERS">CALL-INITIALIZERS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Calls all the initializers specified on CLASS in their proper sequence.

CLASS can be either an instance of a WIDGET-CLASS, a
WIDGET-CLASS itself, or a symbol naming the class.</pre></div> </article> </li><li> <a name="QTOOLS:CAPITALIZE-ON"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:CAPITALIZE-ON">CAPITALIZE-ON</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CHARACTER STRING &amp;OPTIONAL (REPLACEMENT CHARACTER) START-CAPITALIZED</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:CL-TYPE-FOR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:CL-TYPE-FOR">CL-TYPE-FOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">QT-TYPE</code><code>)</code>  </header> <div class="docstring"><pre>Attempts to determine the CL type for the given Qt type descriptor.

Look at the source to see the mappings.</pre></div> </article> </li><li> <a name="QTOOLS:CLEAR-METHOD-INFO"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:CLEAR-METHOD-INFO">CLEAR-METHOD-INFO</a></code></h4> <code class="qualifiers"></code> <code class="arguments"></code><code>)</code>  </header> <div class="docstring"><pre>Clears the *QMETHODS* table.

See <a href="#QTOOLS:*QMETHODS*">QTOOLS:*QMETHODS*</a></pre></div> </article> </li><li> <a name="QTOOLS:COMPILE-WRAPPER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:COMPILE-WRAPPER">COMPILE-WRAPPER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">METHOD</code><code>)</code>  </header> <div class="docstring"><pre>Compiles the wrapper function for METHOD.

This does not actually call CL:COMPILE, or change
the global environment in any way. It instead returns
a form that you can then truly compile, print, or write
to file, or whatever your intention is.

See <a href="#QTOOLS:ENSURE-METHODS">QTOOLS:ENSURE-METHODS</a>
See <a href="NIL">QT:QMETHOD-ENUM-P</a>
See <a href="#QTOOLS:COMPILE-CONSTANT">QTOOLS:COMPILE-CONSTANT</a>
See <a href="NIL">QT:QMETHOD-CTOR-P</a>
See <a href="NIL">QT:QMETHOD-COPYCTOR-P</a>
See <a href="#QTOOLS:COMPILE-CONSTRUCTOR">QTOOLS:COMPILE-CONSTRUCTOR</a>
See <a href="#QTOOLS:QMETHOD-OPERATOR-P">QTOOLS:QMETHOD-OPERATOR-P</a>
See <a href="#QTOOLS:COMPILE-OPERATOR">QTOOLS:COMPILE-OPERATOR</a>
See <a href="NIL">QT:QMETHOD-STATIC-P</a>
See <a href="#QTOOLS:COMPILE-STATIC-METHOD">QTOOLS:COMPILE-STATIC-METHOD</a>
See <a href="#QTOOLS:COMPILE-METHOD">QTOOLS:COMPILE-METHOD</a></pre></div> </article> </li><li> <a name="QTOOLS:COPY-QOBJECT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:COPY-QOBJECT">COPY-QOBJECT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:DEFAULT-APPLICATION-NAME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFAULT-APPLICATION-NAME">DEFAULT-APPLICATION-NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments"></code><code>)</code>  </header> <div class="docstring"><pre>Attempts to find and return a default name to use for the application.</pre></div> </article> </li><li> <a name="QTOOLS:DESCRIBE-COPY-METHOD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DESCRIBE-COPY-METHOD">DESCRIBE-COPY-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Prints information about the copy method for the specified class if possible.</pre></div> </article> </li><li> <a name="QTOOLS:DESCRIBE-FINALIZE-METHOD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DESCRIBE-FINALIZE-METHOD">DESCRIBE-FINALIZE-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Prints information about the finalize method for the given class if possible.</pre></div> </article> </li><li> <a name="QTOOLS:DESCRIBE-PRINT-METHOD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DESCRIBE-PRINT-METHOD">DESCRIBE-PRINT-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Prints information about the print method for the specified class if possible.</pre></div> </article> </li><li> <a name="QTOOLS:DETERMINED-TYPE-METHOD-NAME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DETERMINED-TYPE-METHOD-NAME">DETERMINED-TYPE-METHOD-NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FUNCTION ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Returns a method designator for the FUNCTION and ARGS.

The FUNCTION is transformed as by TO-METHOD-NAME.
Argument types are determined as follows:
If the argument is a CONS, the CAR is taken as a value (and thus discarded)
and the CDR is the literal type to take. Otherwise the type is determined
by EQT-TYPE-OF.</pre></div> </article> </li><li> <a name="QTOOLS:DIRECT-QSUBCLASS-P"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DIRECT-QSUBCLASS-P">DIRECT-QSUBCLASS-P</a></code></h4> <code class="qualifiers"></code> <code class="arguments">QCLASS MAYBE-SUPERCLASS</code><code>)</code>  </header> <div class="docstring"><pre>Returns T if MAYBE-SUPERCLASS is a direct superclass of QCLASS.</pre></div> </article> </li><li> <a name="QTOOLS:DISPATCH-BY-QCLASS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DISPATCH-BY-QCLASS">DISPATCH-BY-QCLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">METHOD-LOCATOR OBJECT &amp;REST ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Dispatches on the given-method locator by the object.

The METHOD-LOCATOR should be a function of a single argument-- a qclass,
which returns the appropriate method for that class or NIL if none.
If the method-locator does not return a function for all classes in the
precedence list for the object, NO-APPLICABLE-METHOD is called.

This binds *QCLASS-PRECEDENCE-LIST*.

See <a href="#QTOOLS:QCLASS-PRECEDENCE-LIST">QCLASS-PRECEDENCE-LIST</a></pre></div> </article> </li><li> <a name="QTOOLS:ECL-TYPE-FOR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:ECL-TYPE-FOR">ECL-TYPE-FOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">QT-TYPE</code><code>)</code>  </header> <div class="docstring"><pre>Same as CL-TYPE-FOR, but signals an error if no matching type could be found.</pre></div> </article> </li><li> <a name="QTOOLS:EMIT-COMPILATION-NOTE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:EMIT-COMPILATION-NOTE">EMIT-COMPILATION-NOTE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FORMAT-STRING &amp;REST ARGS</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:ENSURE-CLASS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:ENSURE-CLASS">ENSURE-CLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">THING</code><code>)</code>  </header> <div class="docstring"><pre>Ensures to return a CLASS.
SYMBOL -&gt; FIND-CLASS
CLASS  -&gt; IDENTITY
STANDARD-OBJECT -&gt; CLASS-OF</pre></div> </article> </li><li> <a name="QTOOLS:ENSURE-METHODS-PROCESSED"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:ENSURE-METHODS-PROCESSED">ENSURE-METHODS-PROCESSED</a></code></h4> <code class="qualifiers"></code> <code class="arguments"></code><code>)</code>  </header> <div class="docstring"><pre>Ensures that all methods have been generated for the currently loaded smoke modules.

See <a href="#QTOOLS:LOADED-SMOKE-MODULES">QTOOLS:LOADED-SMOKE-MODULES</a>
See <a href="#QTOOLS:*GENERATED-MODULES*">QTOOLS:*GENERATED-MODULES*</a>
See <a href="#QTOOLS:PROCESS-ALL-METHODS">QTOOLS:PROCESS-ALL-METHODS</a></pre></div> </article> </li><li> <a name="QTOOLS:ENSURE-Q+-METHOD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:ENSURE-Q+-METHOD">ENSURE-Q+-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FUNCTION</code><code>)</code>  </header> <div class="docstring"><pre>Ensures that the Q+ FUNCTION exists by compiling it on the fly.
Raises an error if no appropriate function can be found.
Returns the proper *TARGET-PACKAGE* symbol for the function.

See <a href="#QTOOLS:ENSURE-METHODS-PROCESSED">QTOOLS:ENSURE-METHODS-PROCESSED</a>
See <a href="#QTOOLS:COMPILE-WRAPPER">QTOOLS:COMPILE-WRAPPER</a>
See <a href="#QTOOLS:*TARGET-PACKAGE*">QTOOLS:*TARGET-PACKAGE*</a></pre></div> </article> </li><li> <a name="QTOOLS:ENSURE-QAPPLICATION"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:ENSURE-QAPPLICATION">ENSURE-QAPPLICATION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;KEY NAME ARGS (MAIN-THREAD T)</code><code>)</code>  </header> <div class="docstring"><pre>Ensures that the QT:*QAPPLICATION* is available, potentially using NAME and ARGS to initialize it.

See <a href="NIL">QT:*QAPPLICATION*</a>
See <a href="NIL">QT:ENSURE-SMOKE</a></pre></div> </article> </li><li> <a name="QTOOLS:ENSURE-QCLASS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:ENSURE-QCLASS">ENSURE-QCLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">THING</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:ENSURE-QOBJECT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:ENSURE-QOBJECT">ENSURE-QOBJECT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">THING</code><code>)</code>  </header> <div class="docstring"><pre>Makes sure that THING is a usable qobject.

If THING is a symbol, it attempts to use MAKE-INSTANCE with it.</pre></div> </article> </li><li> <a name="QTOOLS:ENUMERATE-METHOD-DESCRIPTORS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:ENUMERATE-METHOD-DESCRIPTORS">ENUMERATE-METHOD-DESCRIPTORS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Returns a list of all possible method descriptors with NAME and ARGS.
Args may be either a list of direct types to use or a list of alternative types.
In the case of lists, the argument alternatives are taken in parallel.

Examples: 
 (.. foo '(a b)) =&gt; (&quot;foo(a,b)&quot;)
 (.. foo '((a b))) =&gt; (&quot;foo(a)&quot; &quot;foo(b)&quot;)
 (.. foo '((a b) (0 1))) =&gt; (&quot;foo(a,0)&quot; &quot;foo(b,1)&quot;)</pre></div> </article> </li><li> <a name="QTOOLS:EQT-CLASS-NAME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:EQT-CLASS-NAME">EQT-CLASS-NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">DESIGNATOR</code><code>)</code>  </header> <div class="docstring"><pre>Returns the string designating an equivalent Qt class, if possible.
If the designator is a string, it is returned immediately without further check.
If it is a symbol, it is resolved through FIND-QT-CLASS-NAME, and if no name can
be found through that, an error is signalled.</pre></div> </article> </li><li> <a name="QTOOLS:EQT-TYPE-OF"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:EQT-TYPE-OF">EQT-TYPE-OF</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Same as QT-TYPE-OF, but signals an error if no matching type could be found.</pre></div> </article> </li><li> <a name="QTOOLS:FINALIZE-QOBJECT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FINALIZE-QOBJECT">FINALIZE-QOBJECT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:FIND-CHILD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FIND-CHILD">FIND-CHILD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WIDGET CHILD-CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Find the first child that is an instance of CHILD-CLASS

See <a href="#QTOOLS:FIND-CHILDREN">FIND-CHILDREN</a></pre></div> </article> </li><li> <a name="QTOOLS:FIND-CHILDREN"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FIND-CHILDREN">FIND-CHILDREN</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WIDGET CHILD-CLASS &amp;KEY FIRST-ONLY</code><code>)</code>  </header> <div class="docstring"><pre>Find all children that are an instance of CHILD-CLASS

If FIRST-ONLY is non-NIL, only the first match is found, otherwise
a list is returned.

See <a href="#QTOOLS:QINSTANCEP">QINSTANCEP</a></pre></div> </article> </li><li> <a name="QTOOLS:FIND-FASTCALL-METHOD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FIND-FASTCALL-METHOD">FIND-FASTCALL-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS NAME &amp;REST ARGTYPES</code><code>)</code>  </header> <div class="docstring"><pre>Attempts to find a matching method on the class.

This is done by iterating over all methods that match the name and comparing
the belonging class and its argument types. If you specify an argument type
that is unknown, an error will be signalled. If no matching method can be
found, NIL is returned.

See <a href="#QTOOLS:FAST-CALL">FAST-CALL</a>
See <a href="#QTOOLS:ENSURE-Q+-METHOD">ENSURE-Q+-METHOD</a></pre></div> </article> </li><li> <a name="QTOOLS:FIND-QT-CLASS-NAME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FIND-QT-CLASS-NAME">FIND-QT-CLASS-NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">DESIGNATOR</code><code>)</code>  </header> <div class="docstring"><pre>Returns the string designating an equivalent Qt class. You can use this to resolve
symbols and 'lisp-ified' names to Qt class names. Hyphens are stripped from the designator.

See <a href="#QTOOLS:*QT-CLASS-MAP*">*QT-CLASS-MAP*</a></pre></div> </article> </li><li> <a name="QTOOLS:FUSE-ALISTS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FUSE-ALISTS">FUSE-ALISTS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ALISTS-LISTS</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:FUSE-PLISTS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FUSE-PLISTS">FUSE-PLISTS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST PLISTS-LISTS</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:GENERIC-SIGNAL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:GENERIC-SIGNAL">GENERIC-SIGNAL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT FUNCTION &amp;REST ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Attempts to signal the function FUNCTION on OBJECT by determining the
types according to the run-time types of the values.

This is SLOW as the signal method has to be determined at run-time and it
is DANGEROUS as the type mapping are ambiguous or even unknown for certain
arguments and as such the wrong signal may be called or even one that does
not actually exist. If you want to explicitly specify the type of the
argument, wrap it in a CONS where the CAR is the value and the CDR is a
string for the according Qt type.

A compiler macro will try to statically determine types as best as possible,
so GENERIC-SIGNAL is save to use for static values.</pre></div> </article> </li><li> <a name="QTOOLS:LOAD-ALL-SMOKE-MODULES"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:LOAD-ALL-SMOKE-MODULES">LOAD-ALL-SMOKE-MODULES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST MODS</code><code>)</code>  </header> <div class="docstring"><pre>Loads all the smoke modules as passed.

See <a href="NIL">QT:ENSURE-SMOKE</a></pre></div> </article> </li><li> <a name="QTOOLS:LOADED-SMOKE-MODULES"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:LOADED-SMOKE-MODULES">LOADED-SMOKE-MODULES</a></code></h4> <code class="qualifiers"></code> <code class="arguments"></code><code>)</code>  </header> <div class="docstring"><pre>Returns a fresh list of currently loaded smoke modules.

See <a href="#QTOOLS:*SMOKE-MODULES*">QTOOLS:*SMOKE-MODULES*</a>
See <a href="NIL">QT:NAMED-MODULE-NUMBER</a></pre></div> </article> </li><li> <a name="QTOOLS:MAKE-CHORD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:MAKE-CHORD">MAKE-CHORD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CHORD</code><code>)</code>  </header> <div class="docstring"><pre>Transforms CHORD into a keychord string, if possible.</pre></div> </article> </li><li> <a name="QTOOLS:MAKE-GC-FINALIZED"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:MAKE-GC-FINALIZED">MAKE-GC-FINALIZED</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Wrap the OBJECT in a GC-FINALIZED instance. Use UNBOX to retrieve the object again.</pre></div> </article> </li><li> <a name="QTOOLS:MAP-COMPILE-ALL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:MAP-COMPILE-ALL">MAP-COMPILE-ALL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FUNCTION</code><code>)</code>  </header> <div class="docstring"><pre>Calls FUNCTION with the result of COMPILE-WRAPPER on all available methods.

See <a href="#QTOOLS:COMPILE-WRAPPER">QTOOLS:COMPILE-WRAPPER</a>
See <a href="#QTOOLS:*QMETHODS*">QTOOLS:*QMETHODS*</a></pre></div> </article> </li><li> <a name="QTOOLS:MAP-LAYOUT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:MAP-LAYOUT">MAP-LAYOUT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FUNCTION LAYOUT</code><code>)</code>  </header> <div class="docstring"><pre>Map all widgets and layouts on LAYOUT onto FUNCTION.</pre></div> </article> </li><li> <a name="QTOOLS:MAYBE-DELETE-QOBJECT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:MAYBE-DELETE-QOBJECT">MAYBE-DELETE-QOBJECT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Deletes the object if possible.</pre></div> </article> </li><li> <a name="QTOOLS:METHOD-SYMBOL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:METHOD-SYMBOL">METHOD-SYMBOL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">METHOD</code><code>)</code>  </header> <div class="docstring"><pre>Returns an appropriate symbol to use for the name of the wrapper function for METHOD.

See <a href="NIL">QT:QMETHOD-ENUM-P</a>
See <a href="#QTOOLS:CL-CONSTANT-NAME">QTOOLS:CL-CONSTANT-NAME</a>
See <a href="NIL">QT:QMETHOD-CTOR-P</a>
See <a href="NIL">QT:QMETHOD-COPYCTOR-P</a>
See <a href="#QTOOLS:CL-CONSTRUCTOR-NAME">QTOOLS:CL-CONSTRUCTOR-NAME</a>
See <a href="#QTOOLS:QMETHOD-OPERATOR-P">QTOOLS:QMETHOD-OPERATOR-P</a>
See <a href="#QTOOLS:CL-OPERATOR-NAME">QTOOLS:CL-OPERATOR-NAME</a>
See <a href="NIL">QT:QMETHOD-STATIC-P</a>
See <a href="#QTOOLS:CL-STATIC-METHOD-NAME">QTOOLS:CL-STATIC-METHOD-NAME</a>
See <a href="#QTOOLS:CL-METHOD-NAME">QTOOLS:CL-METHOD-NAME</a></pre></div> </article> </li><li> <a name="QTOOLS:PRINT-QOBJECT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:PRINT-QOBJECT">PRINT-QOBJECT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INSTANCE STREAM</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:PROCESS-ALL-METHODS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:PROCESS-ALL-METHODS">PROCESS-ALL-METHODS</a></code></h4> <code class="qualifiers"></code> <code class="arguments"></code><code>)</code>  </header> <div class="docstring"><pre>Clears the method table and generates all possible data for the currently available methods.
This also sets the *GENERATED-MODULES* to the proper value.

See <a href="NIL">QT:MAP-METHODS</a>
See <a href="#QTOOLS:PROCESS-METHOD">QTOOLS:PROCESS-METHOD</a>
See <a href="#QTOOLS:CLEAR-METHOD-INFO">QTOOLS:CLEAR-METHOD-INFO</a>
See <a href="#QTOOLS:*GENERATED-MODULES*">QTOOLS:*GENERATED-MODULES*</a>
See <a href="#QTOOLS:LOADED-SMOKE-MODULES">QTOOLS:LOADED-SMOKE-MODULES</a></pre></div> </article> </li><li> <a name="QTOOLS:PROCESS-METHOD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:PROCESS-METHOD">PROCESS-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">METHOD</code><code>)</code>  </header> <div class="docstring"><pre>Push the given METHOD onto its appropriate place in the method table, if it is needed.

See <a href="#QTOOLS:METHOD-NEEDED-P">QTOOLS:METHOD-NEEDED-P</a>
See <a href="#QTOOLS:METHOD-SYMBOL">QTOOLS:METHOD-SYMBOL</a>
See <a href="#QTOOLS:*QMETHODS*">QTOOLS:*QMETHODS*</a></pre></div> </article> </li><li> <a name="QTOOLS:Q+-COMPILE-AND-LOAD"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:Q+-COMPILE-AND-LOAD">Q+-COMPILE-AND-LOAD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;KEY MODULES (FILE (MERGE-PATHNAMES &quot;q+.lisp&quot; (TEMPORARY-DIRECTORY)))</code><code>)</code>  </header> <div class="docstring"><pre>Writes, compiles, and loads the file for all generated Qt wrapper functions.
If MODULES is passed, CommonQt is reloaded and only the given modules are loaded.

See <a href="#QTOOLS:WRITE-EVERYTHING-TO-FILE">WRITE-EVERYTHING-TO-FILE</a></pre></div> </article> </li><li> <a name="QTOOLS:Q+APROPOS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:Q+APROPOS">Q+APROPOS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TERM</code><code>)</code>  </header> <div class="docstring"><pre>Searches for Q+ functions that match the term given.

This function is useful to determine the proper converted name for a method or
enum, or to generally discover methods if you cannot recall what it was called
exactly. You can separate terms by a space and only methods that match each
individual term will be shown. Matches are case-insensitive and ignore hyphens
as well as underscores and dots.

Example: (q+apropos &quot;qimage format&quot;)

Q+::QIMAGE.FORMAT_INVALID
...

This function calls ENSURE-METHODS-PROCESSED before performing the search to
ensure the method cache is fully populated according to the currently loaded
 modules.

See <a href="#QTOOLS:ENSURE-METHODS-PROCESSED">QTOOLS:ENSURE-METHODS-PROCESSED</a>
See <a href="#QTOOLS:*QMETHODS*">QTOOLS:*QMETHODS*</a></pre></div> </article> </li><li> <a name="QTOOLS:QCLASS-PRECEDENCE-LIST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:QCLASS-PRECEDENCE-LIST">QCLASS-PRECEDENCE-LIST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">QCLASS</code><code>)</code>  </header> <div class="docstring"><pre>Returns the class precedence list for the given qclass.

See <a href="NIL">*QCLASS-PRECEDENCE-LISTS*</a>
See <a href="NIL">COMPUTE-QCLASS-PRECEDENCE-LIST</a></pre></div> </article> </li><li> <a name="QTOOLS:QINSTANCEP"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:QINSTANCEP">QINSTANCEP</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INSTANCE CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Tests whether INSTANCE is an INSTANCE of CLASS.

This includes subclasses, so a QSlider instance is also
an instance of a QWidget and so forth.</pre></div> </article> </li><li> <a name="QTOOLS:QOBJECT-ALIVE-P"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:QOBJECT-ALIVE-P">QOBJECT-ALIVE-P</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Returns T if the object is not null and not deleted.</pre></div> </article> </li><li> <a name="QTOOLS:QT-TYPE-FOR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:QT-TYPE-FOR">QT-TYPE-FOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CL-TYPE</code><code>)</code>  </header> <div class="docstring"><pre>Attempts to determine the proper Qt type descriptor for the passed cl type name.

Look at the source to see the mappings.</pre></div> </article> </li><li> <a name="QTOOLS:QT-TYPE-OF"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:QT-TYPE-OF">QT-TYPE-OF</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Attempts to determine a proper Qt type descriptor for the type of the OBJECT.

Look at the source to see the mappings.</pre></div> </article> </li><li> <a name="QTOOLS:REMOVE-FINALIZER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REMOVE-FINALIZER">REMOVE-FINALIZER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WIDGET-CLASS FINALIZER</code><code>)</code>  </header> <div class="docstring"><pre>Removes the FINALIZER definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the slot.

See <a href="#QTOOLS:REMOVE-WIDGET-CLASS-OPTION">QTOOLS:REMOVE-WIDGET-CLASS-OPTION</a>
See <a href="#QTOOLS:ENSURE-CLASS">QTOOLS:ENSURE-CLASS</a></pre></div> </article> </li><li> <a name="QTOOLS:REMOVE-INITIALIZER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REMOVE-INITIALIZER">REMOVE-INITIALIZER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WIDGET-CLASS INITIALIZER</code><code>)</code>  </header> <div class="docstring"><pre>Removes the INITIALIZER definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the slot.

See <a href="#QTOOLS:REMOVE-WIDGET-CLASS-OPTION">QTOOLS:REMOVE-WIDGET-CLASS-OPTION</a>
See <a href="#QTOOLS:ENSURE-CLASS">QTOOLS:ENSURE-CLASS</a></pre></div> </article> </li><li> <a name="QTOOLS:REMOVE-MENU-CONTENT-TYPE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REMOVE-MENU-CONTENT-TYPE">REMOVE-MENU-CONTENT-TYPE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME</code><code>)</code>  </header> <div class="docstring"><pre>Removes the menu content type NAME.</pre></div> </article> </li><li> <a name="QTOOLS:REMOVE-METHOD-DECLARATION"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REMOVE-METHOD-DECLARATION">REMOVE-METHOD-DECLARATION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME</code><code>)</code>  </header> <div class="docstring"><pre>Remove the method declaration processor function of NAME.</pre></div> </article> </li><li> <a name="QTOOLS:REMOVE-OVERRIDE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REMOVE-OVERRIDE">REMOVE-OVERRIDE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WIDGET-CLASS OVERRIDE</code><code>)</code>  </header> <div class="docstring"><pre>Removes the OVERRIDE definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the override.

See <a href="#QTOOLS:REMOVE-WIDGET-CLASS-OPTION">QTOOLS:REMOVE-WIDGET-CLASS-OPTION</a>
See <a href="#QTOOLS:ENSURE-CLASS">QTOOLS:ENSURE-CLASS</a></pre></div> </article> </li><li> <a name="QTOOLS:REMOVE-SIGNAL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REMOVE-SIGNAL">REMOVE-SIGNAL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WIDGET-CLASS SIGNAL</code><code>)</code>  </header> <div class="docstring"><pre>Removes the SIGNAL definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the slot.

See <a href="#QTOOLS:REMOVE-WIDGET-CLASS-OPTION">QTOOLS:REMOVE-WIDGET-CLASS-OPTION</a>
See <a href="#QTOOLS:ENSURE-CLASS">QTOOLS:ENSURE-CLASS</a></pre></div> </article> </li><li> <a name="QTOOLS:REMOVE-SLOT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REMOVE-SLOT">REMOVE-SLOT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WIDGET-CLASS SLOT</code><code>)</code>  </header> <div class="docstring"><pre>Removes the SLOT definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the slot.

See <a href="#QTOOLS:REMOVE-WIDGET-CLASS-OPTION">QTOOLS:REMOVE-WIDGET-CLASS-OPTION</a>
See <a href="#QTOOLS:ENSURE-CLASS">QTOOLS:ENSURE-CLASS</a></pre></div> </article> </li><li> <a name="QTOOLS:REMOVE-SUBWIDGET"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REMOVE-SUBWIDGET">REMOVE-SUBWIDGET</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WIDGET-CLASS SUBWIDGET</code><code>)</code>  </header> <div class="docstring"><pre>Removes the SUBWIDGET definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the subwidget.
It does however remove the class-slot and initializer of the subwidget.

See <a href="#QTOOLS:REMOVE-WIDGET-CLASS-OPTION">QTOOLS:REMOVE-WIDGET-CLASS-OPTION</a>
See <a href="#QTOOLS:ENSURE-CLASS">QTOOLS:ENSURE-CLASS</a></pre></div> </article> </li><li> <a name="QTOOLS:REMOVE-WIDGET-CLASS-OPTION"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:REMOVE-WIDGET-CLASS-OPTION">REMOVE-WIDGET-CLASS-OPTION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS OPTION IDENTIFIER &amp;KEY (KEY (FUNCTION FIRST)) (TEST (FUNCTION EQUAL))</code><code>)</code>  </header> <div class="docstring"><pre>Removes a CLASS OPTION value.

The value is identified and distinguished within the OPTION list
by TEST on KEY. If the first item in the sub-list is EQUAL to IDENTIFIER,
it is removed. This causes a call to SOFTLY-REDEFINE-WIDGET-CLASS.

See <a href="#QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS.">QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS.</a>
See <a href="#QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS.">QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS.</a></pre></div> </article> </li><li> <a name="QTOOLS:SET-WIDGET-CLASS-OPTION"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:SET-WIDGET-CLASS-OPTION">SET-WIDGET-CLASS-OPTION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS OPTION VALUE &amp;KEY (KEY (FUNCTION FIRST)) (TEST (FUNCTION EQUAL))</code><code>)</code>  </header> <div class="docstring"><pre>Sets a CLASS OPTION VALUE.

The value is identified and distinguished within the OPTION list
by TEST on KEY. If a matching list can be found, it is replaced
at the same position. Otherwise it is appended to the end of the
list. The order here is important to preserve load-order.

See <a href="#QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS.">QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS.</a>
See <a href="#QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS.">QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS.</a></pre></div> </article> </li><li> <a name="QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS">SOFTLY-REDEFINE-WIDGET-CLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS</code><code>)</code>  </header> <div class="docstring"><pre>Cause a soft redefinition of the given CLASS.

This will in effect cause a call to REINITIALIZE-INSTANCE with the proper
class options added from WIDGET-CLASS-DIRECT-OPTIONS, followed by a
FINALIZE-INHERITANCE call on the class.</pre></div> </article> </li><li> <a name="QTOOLS:SPECIFIED-TYPE-METHOD-NAME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:SPECIFIED-TYPE-METHOD-NAME">SPECIFIED-TYPE-METHOD-NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FUNCTION ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Returns a method designator for the FUNCTION and ARGS.

The FUNCTION is transformed as by TO-METHOD-NAME. Each argument type is
determined as by TO-TYPE-NAME.</pre></div> </article> </li><li> <a name="QTOOLS:SPLIT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:SPLIT">SPLIT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">LIST ITEMS &amp;KEY (KEY (FUNCTION IDENTITY)) (TEST (FUNCTION EQL))</code><code>)</code>  </header> <div class="docstring"><pre>Segregates items in LIST into separate lists if they mach an item in ITEMS.
The first item in the returned list is the list of unmatched items.

Example:
 (split '((0 a) (0 b) (1 a) (1 b) (2 c)) '(0 2) :key #'car)
 =&gt; '(((1 a) (1 b)) ((0 a) (0 b)) ((2 c))) </pre></div> </article> </li><li> <a name="QTOOLS:SWEEP-LAYOUT"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:SWEEP-LAYOUT">SWEEP-LAYOUT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">LAYOUT</code><code>)</code>  </header> <div class="docstring"><pre>Removes all widgets from the layout and finalizes them.</pre></div> </article> </li><li> <a name="QTOOLS:TO-METHOD-NAME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:TO-METHOD-NAME">TO-METHOD-NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">THING</code><code>)</code>  </header> <div class="docstring"><pre>Turns THING into a Qt method name.
If THING is a STRING, it is returned directly.
If THING is a SYMBOL, it is transformed by turning each
character after a hyphen into its uppercase equivalent
and dropping the hyphen. Therefore: foo-bar fooBar</pre></div> </article> </li><li> <a name="QTOOLS:TO-QBYTE-ARRAY"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:TO-QBYTE-ARRAY">TO-QBYTE-ARRAY</a></code></h4> <code class="qualifiers"></code> <code class="arguments">VECTOR</code><code>)</code>  </header> <div class="docstring"><pre>Translates an unsigned-byte 8 vector into a QByteArray.</pre></div> </article> </li><li> <a name="QTOOLS:TO-TYPE-NAME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:TO-TYPE-NAME">TO-TYPE-NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">THING</code><code>)</code>  </header> <div class="docstring"><pre>Returns the type name for THING.

If THING is a string, it is returned directly.
If it is a symbol, either QT-TYPE-FOR for THING is
returned, or the STRING-DOWNCASE of THING.</pre></div> </article> </li><li> <a name="QTOOLS:TRANSLATE-NAME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:TRANSLATE-NAME">TRANSLATE-NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME TYPE &amp;OPTIONAL (ERROR-P T)</code><code>)</code>  </header> <div class="docstring"><pre>Translates the given name to the requested type, if possible.

When ERROR-P is T and no translation can be found, an error is signalled.
Otherwise in that case NIL is returned.

See <a href="NIL">TRANSLATOR</a></pre></div> </article> </li><li> <a name="QTOOLS:WIDGET-CLASS-OPTION-P"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WIDGET-CLASS-OPTION-P">WIDGET-CLASS-OPTION-P</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CLASS OPTION VALUE &amp;KEY (KEY (FUNCTION FIRST)) (TEST (FUNCTION EQUAL))</code><code>)</code>  </header> <div class="docstring"><pre>Tests if OPTION VALUE is already present on CLASS.
Returns the full option value if it can be found.

See <a href="#QTOOLS:SET-WIDGET-CLASS-OPTION">QTOOLS:SET-WIDGET-CLASS-OPTION</a></pre></div> </article> </li><li> <a name="QTOOLS:WRITE-EVERYTHING-TO-FILE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WRITE-EVERYTHING-TO-FILE">WRITE-EVERYTHING-TO-FILE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">PATHNAME &amp;KEY (PACKAGE *TARGET-PACKAGE*) (IF-EXISTS :SUPERSEDE)</code><code>)</code>  </header> <div class="docstring"><pre>Writes all compileable Qt method wrappers to PATHNAME.

PACKAGE designates in which package the symbols will live.
This makes it possible to deviate from the standard of
*TARGET-PACKAGE*. The value of QTOOLS:*TARGET-PACKAGE*
will be automatically set to this once the resulting file
is LOADed or compiled again.

See <a href="#QTOOLS:WRITE-FORMS">QTOOLS:WRITE-FORMS</a>
See <a href="#QTOOLS:*TARGET-PACKAGE*">QTOOLS:*TARGET-PACKAGE*</a></pre></div> </article> </li><li> <a name="QTOOLS:WRITE-SMOKE-MODULE-SYSTEM-FILE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WRITE-SMOKE-MODULE-SYSTEM-FILE">WRITE-SMOKE-MODULE-SYSTEM-FILE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">MODULE &amp;KEY (DEPENDENCIES '(T NIL)) LIBRARY-FILES
 (PATH (SYSTEM-RELATIVE-PATHNAME :QTOOLS (FORMAT NIL &quot;smoke/~(~a~).asd&quot; MODULE)))</code><code>)</code>  </header> <div class="docstring"><pre>Writes a SMOKE-MODULE-SYSTEM form to the given PATH.

See <a href="#QTOOLS:COMPILE-SMOKE-MODULE-SYSTEM-DEFINITION">QTOOLS:COMPILE-SMOKE-MODULE-SYSTEM-DEFINITION</a></pre></div> </article> </li><li> <a name="QTOOLS:CONSTRUCT"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:CONSTRUCT">CONSTRUCT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">WIDGET</code><code>)</code>  </header> <div class="docstring"><pre>This method is called during the initialization of a widget instance.
It MUST call QT:NEW on the widget at some point. Its primary
purpose is to give the user some way to manipulate which arguments
are passed to QT:NEW. By default, no arguments are passed.</pre></div> </article> </li><li> <a name="QTOOLS:COPY"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:COPY">COPY</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code><code>)</code>  </header> <div class="docstring"><pre>Generates a copy of the object.

The way objects are copied varies, but usually it can be assumed that the
copy is made in a way such that data immediately associated with the object
is copied (such as pixel data in an image), but data only implicitly
referenced (such as the paint device of a painter) is not.

Use DESCRIBE-COPY-METHOD for information on a specific copying mechanism.

Uses COPY-QOBJECT-USING-CLASS and determines the class by QT::QOBJECT-CLASS.</pre></div> </article> </li><li> <a name="QTOOLS:FINALIZE"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FINALIZE">FINALIZE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Finalizes the object. The effects thereof may vary and even result in nothing at all.
After FINALIZE has been called on an object, it should not be attempted to be used in any fashion
whatsoever as it may have been rendered unusable or unstable.

This method should be called on any object once it is known that it can be discarded.
FINALIZE will then try to clean up objects and make sure that they don't clutter your
memory, as lingering QOBJECTs would.</pre></div> </article> </li><li> <a name="QTOOLS:FINALIZED"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FINALIZED">FINALIZED</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:UNBOX"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:UNBOX">UNBOX</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li> <a name="QTOOLS:CONNECT!"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:CONNECT!">CONNECT!</a></code></h4> <code class="qualifiers"></code> <code class="arguments">ORIGIN ORIGIN-FUNCTION TARGET TARGET-FUNCTION</code><code>)</code>  </header> <div class="docstring"><pre>Macro for a more lisp-y writing of CONNECT.
ORIGIN-FUNCTION and TARGET-FUNCTION should both be a list of the METHOD-NAME
followed by Qt argument types. The effective method name is computed as per
SPECIFIED-TYPE-METHOD-NAME.

ORIGIN and TARGET can both be either a single object or a list of objects
to connect with each other.</pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-1-&gt;1-TRANSLATOR"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-1-&gt;1-TRANSLATOR">DEFINE-1-&gt;1-TRANSLATOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TYPE MATCH RESULT &amp;KEY (TEST '(FUNCTION STRING-EQUAL)) (PRIORITY 0)</code><code>)</code>  </header> <div class="docstring"><pre>Defines a translator for a one to one mapping.

The match is compared to the inputted name by STRING-EQUAL by default. A different
comparison function can be specified through the TEST keyword argument. This function
receives the given name to be translated as the first argument and the match as the
second.

The match is used as the name after being interned.

See <a href="#QTOOLS:DEFINE-SIMPLE-TRANSLATOR">DEFINE-SIMPLE-TRANSLATOR</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-COPY-METHOD"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-COPY-METHOD">DEFINE-COPY-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(INSTANCE CLASS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a method to copy an object of CLASS.
CLASS can be either a common-lisp class type or a Qt class name.

Qt class names will take precedence, meaning that if CLASS resolves
to a name using FIND-QT-CLASS-NAME a QCLASS-COPY method
is defined on the respective qt-class. Otherwise a COPY method
is defined with the CLASS directly as specializer for the instance.

In cases where you need to define a method on a same-named CL class,
directly use DEFMETHOD on COPY-QOBJECT.

See <a href="#QTOOLS:COPY-QOBJECT">COPY-QOBJECT</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-FINALIZABLE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-FINALIZABLE">DEFINE-FINALIZABLE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME DIRECT-SUPERCLASSES DIRECT-SLOTS &amp;REST OPTIONS</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand around DEFCLASS to create a finalizable class.

Automatically adds FINALIZABLE as direct-superclass and 
FINALIZABLE-CLASS as metaclass.</pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-FINALIZE-METHOD"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-FINALIZE-METHOD">DEFINE-FINALIZE-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(INSTANCE CLASS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a method to finalize an object of CLASS.
CLASS can be either a common-lisp class type or a Qt class name.

Qt class names will take precedence, meaning that if CLASS resolves
to a name using FIND-QT-CLASS-NAME a FINALIZE-QCLASS method
is defined on the respective qt-class. Otherwise a FINALIZE method
is defined with the CLASS directly as specializer for the instance.

In cases where you need to define a method on a same-named CL class,
directly use DEFMETHOD on FINALIZE.

See <a href="#QTOOLS:FINALIZE">FINALIZE</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-FINALIZER"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-FINALIZER">DEFINE-FINALIZER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(WIDGET-CLASS METHOD-NAME &amp;OPTIONAL (PRIORITY 0)) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a new finalizer of METHOD-NAME on WIDGET-CLASS.

Finalizers are functions that are run immediately after the widget has been
FINALIZED, but before the main FINALIZE method kicks in. This means that the
widget will still be allocated at the time. Finalizers are executed in order 
of highest PRIORITY first. 

This is translated to a method definition specialised (and bound) on WIDGET-CLASS
with a FINALIZER declaration. The BODY is wrapped in a WITH-SLOTS-BOUND form.

See <a href="NIL">CL+QT:DEFMETHOD</a>
See <a href="#QTOOLS:WITH-SLOTS-BOUND">QTOOLS:WITH-SLOTS-BOUND</a>
See <a href="#QTOOLS:FINALIZE">QTOOLS:FINALIZE</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-INITIALIZER"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-INITIALIZER">DEFINE-INITIALIZER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(WIDGET-CLASS METHOD-NAME &amp;OPTIONAL (PRIORITY 0)) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a new initializer of METHOD-NAME on WIDGET-CLASS.

Initializers are functions that are run immediately after the widget has been
allocated by QT:NEW, but before any INITIALIZE-INSTANCE:AFTER methods are
executed. They are executed in order of highest PRIORITY first. 

This is translated to a method definition specialised (and bound) on WIDGET-CLASS
with a INITIALIZER declaration. The BODY is wrapped in a WITH-SLOTS-BOUND form.

See <a href="NIL">CL+QT:DEFMETHOD</a>
See <a href="#QTOOLS:WITH-SLOTS-BOUND">QTOOLS:WITH-SLOTS-BOUND</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-MENU"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-MENU">DEFINE-MENU</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(WIDGET-CLASS NAME) &amp;BODY CONTENTS</code><code>)</code>  </header> <div class="docstring"><pre>Defines a menu on WIDGET-CLASS with NAME and CONTENTS.

By default the following content types are available:
  A :MENU form is followed by a menu text string and a
  body of content forms.

  A :SEPARATOR simply adds a separator at its point to
  the parent and takes no further arguments.

  An :ITEM form is followed by an identifier, which may
  be a symbol, string, or list. In the case of a symbol,
  the item is taken from the according slot on the widget.
  In the case of a string the string serves as the text
  for the item. For a list, the first serves as the text
  and the second as an input acceptable to MAKE-CHORD.
  The body of the item form can be arbitrary lisp forms
  to be executed when the item is triggered.

See <a href="#QTOOLS:MAKE-CHORD.">QTOOLS:MAKE-CHORD.</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-MENU-CONTENT-TYPE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-MENU-CONTENT-TYPE">DEFINE-MENU-CONTENT-TYPE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TYPE (PARENT &amp;REST ARGS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a new menu content type processor NAME.

See <a href="NIL">(SETF</a> QTOOLS:MENU-CONTENT-TYPE).</pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-METHOD-DECLARATION"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-METHOD-DECLARATION">DEFINE-METHOD-DECLARATION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME ARGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Define a new method declaration function of NAME.

See <a href="NIL">(SETF</a> QTOOLS:METHOD-DECLARATION).</pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-OBJECT"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-OBJECT">DEFINE-OBJECT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME (QT-CLASS &amp;REST DIRECT-SUPERCLASSES) DIRECT-SLOTS &amp;REST OPTIONS</code><code>)</code>  </header> <div class="docstring"><pre>Alias for DEFINE-WIDGET.

This is merely here for clarity.

See <a href="#QTOOLS:DEFINE-WIDGET">QTOOLS:DEFINE-WIDGET</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-OVERRIDE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-OVERRIDE">DEFINE-OVERRIDE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(WIDGET-CLASS OVERRIDE &amp;OPTIONAL METHOD-NAME) ARGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Define a new OVERRIDE on WIDGET-CLASS with ARGS.

This is translated to a method definition with METHOD-NAME that specialises
 (and binds) on WIDGET-CLASS, with ARGS appended to the list, and an OVERRIDE
declaration in the body. Additionally, the body is wrapped in a WITH-SLOTS-BOUND
to allow for convenient slot access.

See <a href="NIL">CL+QT:DEFMETHOD</a>
See <a href="#QTOOLS:WITH-SLOTS-BOUND">QTOOLS:WITH-SLOTS-BOUND</a>
See <a href="NIL">CommonQt/override</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-PRINT-METHOD"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-PRINT-METHOD">DEFINE-PRINT-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(INSTANCE CLASS STREAM) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a method to print an object of CLASS.
CLASS can be either a common-lisp class type or a Qt class name.

Qt class names will take precedence, meaning that if CLASS resolves
to a name using FIND-QT-CLASS-NAME a QCLASS-PRINT method
is defined on the respective qt-class. Otherwise a PRINT-OBJECT method
is defined with the CLASS directly as specializer for the instance.

In cases where you need to define a method on a same-named CL class,
directly use DEFMETHOD on PRINT-OBJECT.

See <a href="http://l1sp.org/cl/print-object">PRINT-OBJECT</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-QCLASS-DISPATCH-FUNCTION"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-QCLASS-DISPATCH-FUNCTION">DEFINE-QCLASS-DISPATCH-FUNCTION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">BASENAME DISPATCHER ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Defines a sort of generic function that dispatches by qclass.

This can be used to write methods that dispatch as CLOS would, but on Qt
internal classes. In specific, it defines the following things all in one:

1. A variable *QCLASS-basename-FUNCTIONS* that contains all the methods you
   define on the function.
2. An accessor function QCLASS-basename-FUNCTION that takes a qclass and
   accesses the appropriate method function.
3. A function REMOVE-QCLASS-basename-FUNCTION to remove a method function.
4. A macro DEFINE-QCLASS-basename-FUNCTION to define a method on the
   qclass generic function. The macro will expect a qclass, a lambda-list,
   and a body as arguments.
5. A function DISPATCHER that is used as the &quot;generic function&quot;.

Note that multiple-dispatch is not possible with this. Dispatch only ever
happens on the first argument, which must be a qclass instance. There is
also no method combination. Defining a second method on the same qclass will
simply replace the old definition.

However the local CALL-NEXT-METHOD and NEXT-METHOD-P functions are available
in a method body.

See <a href="NIL">GENERATE-QCLASS-DISPATCH-LAMBDA</a>
See <a href="#QTOOLS:DISPATCH-BY-QCLASS">DISPATCH-BY-QCLASS</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-SIGNAL"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-SIGNAL">DEFINE-SIGNAL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(WIDGET-CLASS SIGNAL) ARGS &amp;BODY OPTIONS</code><code>)</code>  </header> <div class="docstring"><pre>Define a new SIGNAL on WIDGET-CLASS with ARGS.

This evaluates to a simple SET-WIDGET-CLASS-OPTION that adds a new :SIGNAL
definition to the WIDGET-CLASS. The signal signature is generated using
SPECIFIED-TYPE-METHOD-NAME.

See <a href="NIL">CommonQt/signals</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-SIGNAL-METHOD"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-SIGNAL-METHOD">DEFINE-SIGNAL-METHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand to define wrapper methods for the given signal.

NAME ::= signal | (signal method-name)
ARGS ::= ARG*
ARG  ::= qt-type | (qt-type*)

A methods with name NAME are generated that takes arguments the
object to signal and the specified arguments with their according types.
You may either specify a single type on each argument, or lists of
correlating types for each argument. Each type is resolved as per
ECL-TYPE-FOR to a type to use in the method specializers. The signal
method to call is computed as per SPECIFIED-TYPE-METHOD-NAME.</pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-SIMPLE-TRANSLATOR"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-SIMPLE-TRANSLATOR">DEFINE-SIMPLE-TRANSLATOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(TYPE NAME &amp;OPTIONAL (PRIORITY 0)) (SOURCE) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Define a translator function for a singular type.

In addition to defining a standard translator, this constructs a name out of the given
type as well as its name. This makes it possible to use the same name in the definition
for multiple types of translators.

See <a href="#QTOOLS:DEFINE-TRANSLATOR">DEFINE-TRANSLATOR</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-SLOT"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-SLOT">DEFINE-SLOT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(WIDGET-CLASS SLOT &amp;OPTIONAL METHOD-NAME) ARGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Define a new SLOT on WIDGET-CLASS with ARGS.

ARGS is a list of arguments, where each item is a list of two values,
the first being the symbol used to bind the value within the function
body, and the second being a type specifier usable for the slot definition
and, if possible, as a specializer in the method. You may specify an
explicit type to use for the method specializer as a third item. If no
explicit type is passed, the Qt type is translated using CL-TYPE-FOR.

In effect this translates to a method definition with METHOD-NAME that
specialises (and binds) on WIDGET-CLASS, with additional required arguments
ARGS, and a SLOT declaration. Additionally, the body is wrapped in a
WITH-SLOTS-BOUND to allow for convenient slot access.

See <a href="#QTOOLS:CL-TYPE-FOR">QTOOLS:CL-TYPE-FOR</a>
See <a href="NIL">CL+QT:DEFMETHOD</a>
See <a href="#QTOOLS:WITH-SLOTS-BOUND">QTOOLS:WITH-SLOTS-BOUND</a>
See <a href="NIL">CommonQt/slots</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-SUBOBJECT"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-SUBOBJECT">DEFINE-SUBOBJECT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(OBJECT-CLASS NAME) INITFORM &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Alias for DEFINE-SUBWIDGET

This is merely here for clarity.

See <a href="#QTOOLS:DEFINE-SUBOBJECT">QTOOLS:DEFINE-SUBOBJECT</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-SUBWIDGET"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-SUBWIDGET">DEFINE-SUBWIDGET</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(WIDGET-CLASS NAME) INITFORM &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a new sub-widget of NAME on WIDGET-CLASS.

What this means is that a finalized slot of NAME is added to WIDGET-CLASS
as well as an initializer function for the slot. The slot for the sub-widget 
is set to the value returned by the INITFORM, after which BODY is run. BODY
is wrapped in a WITH-SLOTS-BOUND form, so all slots are conveniently available.

See <a href="#QTOOLS:DEFINE-INITIALIZER">QTOOLS:DEFINE-INITIALIZER</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-TRANSLATOR"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-TRANSLATOR">DEFINE-TRANSLATOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME (SOURCE TYPE &amp;OPTIONAL (PRIORITY 0)) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Define a translator function.

A translator takes a name and should translate it to the requested type of name if it can.
If it cannot, then it should simply return NIL, otherwise the translated name.

See <a href="NIL">TRANSLATOR</a></pre></div> </article> </li><li> <a name="QTOOLS:DEFINE-WIDGET"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DEFINE-WIDGET">DEFINE-WIDGET</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME (QT-CLASS &amp;REST DIRECT-SUPERCLASSES) DIRECT-SLOTS &amp;REST OPTIONS</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand over DEFCLASS.

Adds WIDGET as direct-superclass if it does not appear as a
superclass to the specified direct-superclasses. Sets 
WIDGET-CLASS as metaclass and qt-class as the qt-superclass 
after resolving it through FIND-QT-CLASS-NAME.

All options are fused as per FUSE-ALISTS. You may therefore use
the same form multiple times.</pre></div> </article> </li><li> <a name="QTOOLS:DO-LAYOUT"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:DO-LAYOUT">DO-LAYOUT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(WIDGET LAYOUT) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Iterate over all WIDGETs on LAYOUT.</pre></div> </article> </li><li> <a name="QTOOLS:FAST-CALL"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FAST-CALL">FAST-CALL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">METHOD-DESCRIPTOR OBJECT &amp;REST ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Performs a fast call on a given method.

This is useful if performance really matters and you have to minimise FFI
call overhead. In exchange it is required that you specify the exact method
signature you want to call and provide all arguments prepared in their proper
types as no marshalling will be done. FAST-CALL also will not read out the
return value.

METHOD-DESCRIPTOR ::= (name class-name arg-type*)
object            --- The instance of the class to call a method on.
                      Must match the given class-name.
args              --- The arguments to call the method with. Their types
                      must match the ones given in the arg-types and must
                      be prepared. Especially objects must be translated
                      to pointers manually. See QT::QOBJECT-POINTER.
name              --- The Q+ name of the method being called.
class-name        --- The Qt class name of the class the method belongs to.

At compile time a matching method number is searched for using
FIND-FASTCALL-METHOD. If no method can be found that matches the class,
name, and argument types, an error is signalled.
The fast call procedure creates a stack for the arguments by WITH-CALL-STACK.
It then uses FAST-DIRECT-CALL on the found method number, class, and
stack to perform the actual call to the method.

See <a href="#QTOOLS:FIND-FASTCALL-METHOD">FIND-FASTCALL-METHOD</a>
See <a href="#QTOOLS:FAST-DIRECT-CALL">FAST-DIRECT-CALL</a>
See <a href="#QTOOLS:WITH-CALL-STACK">WITH-CALL-STACK</a></pre></div> </article> </li><li> <a name="QTOOLS:FAST-DIRECT-CALL"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FAST-DIRECT-CALL">FAST-DIRECT-CALL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">METHOD OBJECT STACK</code><code>)</code>  </header> <div class="docstring"><pre>Directly calls the given Qt class method on the given object using the
specified STACK as arguments to supply to the method.

Note that METHOD must be an existing Qt method number, OBJECT must be a
pointer to a class instance that is compatible with the method, and STACK
must be a pointer to an argument stack, preferably created through
WITH-CALL-STACK.

See <a href="#QTOOLS:WITH-CALL-STACK">WITH-CALL-STACK</a>
See <a href="#QTOOLS:FAST-CALL">FAST-CALL</a></pre></div> </article> </li><li> <a name="QTOOLS:FSETF"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:FSETF">FSETF</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST PAIRS</code><code>)</code>  </header> <div class="docstring"><pre>Finalizing SETF. The same as CL+QT:SETF, but performs a FINALIZE on the place first.
The finalize is performed before the place is set, but after the new value is evaluated.</pre></div> </article> </li><li> <a name="QTOOLS:Q+"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:Q+">Q+</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FUNCTION &amp;REST ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Emits a function call to the Q+ FUNCTION with ARGS.

This macro does a bit of a complicated thing:
Firstly, it calls ENSURE-Q+-METHOD on FUNCTION to
make sure that the function object exists at compile
time. Then it emits a PROGN form that contains two
forms, the first of which is a LOAD-TIME-VALUE form
with a call to ENSURE-Q+-METHOD again. This is required
since the function compiled by ENSURE-Q+-METHOD is not
dumped to file anywhere and thus must be recreated at
load time to be available. The second form in the PROGN
is the actual function call, using the proper symbol
from the *TARGET-PACKAGE*.

See <a href="#QTOOLS:ENSURE-Q+-METHOD">QTOOLS:ENSURE-Q+-METHOD</a></pre></div> </article> </li><li> <a name="QTOOLS:Q+FUN"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:Q+FUN">Q+FUN</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FUNCTION</code><code>)</code>  </header> <div class="docstring"><pre>Emits a form that evaluates to the function object of FUNCTION.

Specifically, it returns a LOAD-TIME-VALUE form that evaluates to
the function object, while ensuring that the function does indeed
exist.

See <a href="#QTOOLS:ENSURE-Q+-METHOD">QTOOLS:ENSURE-Q+-METHOD</a></pre></div> </article> </li><li> <a name="QTOOLS:QCLASS=CASE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:QCLASS=CASE">QCLASS=CASE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INSTANCE &amp;BODY CASES</code><code>)</code>  </header> <div class="docstring"><pre>Similar to QTYPECASE, but only supports equality comparisons with classes, not subtype relations.
You should use this if you care about reasonably performant class type comparisons.</pre></div> </article> </li><li> <a name="QTOOLS:QTENUMCASE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:QTENUMCASE">QTENUMCASE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">KEYFORM &amp;BODY FORMS</code><code>)</code>  </header> <div class="docstring"><pre>Similar to CASE:

KEYFORM  --- A form that evaluates to the key to compare against.
CASES    ::= CASE*
CASE     ::= (KEY form*)
KEY      ::= (OR form*) | FORM | t | otherwise</pre></div> </article> </li><li> <a name="QTOOLS:QTYPECASE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:QTYPECASE">QTYPECASE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INSTANCE &amp;BODY CASES</code><code>)</code>  </header> <div class="docstring"><pre>Analogous to CL:TYPECASE, but for Qt classes.

See <a href="#QTOOLS:QINSTANCEP">QINSTANCEP</a></pre></div> </article> </li><li> <a name="QTOOLS:SIGNAL!"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:SIGNAL!">SIGNAL!</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT FUNCTION &amp;REST ARGS</code><code>)</code>  </header> <div class="docstring"><pre>Macro for a more lisp-y writing of EMIT-SIGNAL.
Function should be a list of the METHOD-NAME followed by Qt argument types.
The effective method name is computed as per SPECIFIED-TYPE-METHOD-NAME.

OBJECT can be either a single object to signal to, or a list of objects.</pre></div> </article> </li><li> <a name="QTOOLS:WITH-ALL-SLOTS-BOUND"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WITH-ALL-SLOTS-BOUND">WITH-ALL-SLOTS-BOUND</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(INSTANCE CLASS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Turns into a WITH-SLOTS with all slots of CLASS.
Class is resolved as per ENSURE-CLASS.</pre></div> </article> </li><li> <a name="QTOOLS:WITH-CALL-STACK"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WITH-CALL-STACK">WITH-CALL-STACK</a></code></h4> <code class="qualifiers"></code> <code class="arguments">STACK ARGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Binds a populated stack area to be used in a fast-call.

ARGS            ::= ARG*
ARG             ::= (value stack-item-type)
value           --- The value to be used at the stack position.
stack-item-type --- It must be a symbol from the CommonQt StackItem union.

The stack is populated in the order of the arguments. The values must be
already of their proper types to be used for SETF CFFI:FOREIGN-SLOT-VALUE.
You may use TRANSLATE-NAME STACK-ITEM to translate a common type name to
the appropriate CommonQt StackItem union value.

See <a href="#QTOOLS:FAST-DIRECT-CALL">FAST-DIRECT-CALL</a>
See <a href="#QTOOLS:FAST-CALL">FAST-CALL</a></pre></div> </article> </li><li> <a name="QTOOLS:WITH-FINALIZING"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WITH-FINALIZING">WITH-FINALIZING</a></code></h4> <code class="qualifiers"></code> <code class="arguments">BINDINGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Executes the body as by LET and calls FINALIZE on all the objects introduced by
the bindings on completion of the body. If an error occurs during the binding phase,
all objects bound up until that point are still finalized. Finalizing happens in
reverse order of the bindings specified.</pre></div> </article> </li><li> <a name="QTOOLS:WITH-FINALIZING*"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WITH-FINALIZING*">WITH-FINALIZING*</a></code></h4> <code class="qualifiers"></code> <code class="arguments">BINDINGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Executes the body as by LET* and calls FINALIZE on all the objects introduced by
the bindings on completion of the body. If an error occurs during the binding phase,
all objects bound up until that point are still finalized. Finalizing happens in
reverse order of the bindings specified.</pre></div> </article> </li><li> <a name="QTOOLS:WITH-GC-FINALIZED"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WITH-GC-FINALIZED">WITH-GC-FINALIZED</a></code></h4> <code class="qualifiers"></code> <code class="arguments">BINDINGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Creates bindings as per LET with the special note that each value of a binding is wrapped
in a GC-FINALIZED. Each bound symbol is shadowed by a SYMBOL-MACROLET, which evaluates to
the bound value as per UNBOX.

In other words, this will look like a standard LET to you, but each value of the let is
automatically ensured to be GC-ed and FINALIZEd once the body exits.</pre></div> </article> </li><li> <a name="QTOOLS:WITH-MAIN-WINDOW"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WITH-MAIN-WINDOW">WITH-MAIN-WINDOW</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(WINDOW INSTANTIATOR &amp;KEY NAME QAPPLICATION-ARGS (BLOCKING T) (MAIN-THREAD)
 (ON-ERROR '(FUNCTION INVOKE-DEBUGGER)) (SHOW T) (FINALIZE T)
 (BODY :BEFORE-EXEC))
 &amp;BODY FORMS</code><code>)</code>  </header> <div class="docstring"><pre>This is the main macro to start your application with.

It does the following:
1. Call ENSURE-QAPPLICATION with the provided NAME and QAPPLICATION-ARGS
2. Run the following in the main thread through TMT:WITH-BODY-IN-MAIN-THREAD
   if MAIN-THREAD is non-NIL and make it non-blocking if BLOCKING is NIL.
3. Establish a handler for ERROR that calls the ON-ERROR function if hit.
4. Bind WINDOW to the result of INSTANTIATOR, passed through ENSURE-QOBJECT
   (This means you can also just use the main window class' name)
5. Evaluate BODY
6. Call Q+:SHOW on WINDOW if SHOW is non-NIL
7. Call Q+:EXEC on *QAPPLICATION*
   This will enter the Qt application's main loop that won't exit until your
   application terminates.
8. Upon termination, call FINALIZE on WINDOW.</pre></div> </article> </li><li> <a name="QTOOLS:WITH-SLOTS-BOUND"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WITH-SLOTS-BOUND">WITH-SLOTS-BOUND</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(INSTANCE CLASS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Turns into a WITH-SLOTS with all direct-slots of CLASS.
Class is resolved as per ENSURE-CLASS.</pre></div> </article> </li><li> <a name="QTOOLS:WITH-WIDGET-CLASS"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#QTOOLS:WITH-WIDGET-CLASS">WITH-WIDGET-CLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(VARIABLE &amp;OPTIONAL (METHOD '*METHOD*)) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Binds VARIABLE to the current symbol name of the widget class as used as a specializer in the method arguments list.
This also signals errors if there is no such specializer or if it is invalid.</pre></div> </article> </li></ul> </li></ul> </article>  </main> </body> </html> 